{"posts":[{"title":"关于第二场NOI Online能力测试相关事项的通知","content":" ","link":"https://OI-Master.github.io/post/guan-yu-di-er-chang-noi-online-neng-li-ce-shi-xiang-guan-shi-xiang-de-tong-zhi/"},{"title":"机器人小T","content":"欢迎使用我的机器人—— 小T ！他是一个 QQ 机器人，加好友后可以跟它聊天，拉至群里且给它管理员的话可以帮你管理该群。 加好友的人请加这个 QQ ：3473979630 。临时会话是不会回答的。 机器人有两种内核，一种是小i机器人内核，一个是图灵机器人内核。小i内核相对稳定，直接私聊或在群里at它即可，或在消息前加上前缀“小T”。如果想用图灵机器人内核，需要在群聊里用，说“小T图灵机+你要说的话”才行哦！ 如果出现问题，请联系我，联系方式为 QQ 。具体链接可以在我的博客主页上找到。 还有，请大家别坑他，因为它才出生，所以 Bug 还有很多。测试并上报没问题。 下面是问卷调查。 ","link":"https://OI-Master.github.io/post/ji-qi-ren-xiao-t/"},{"title":"Codeforces Contest 1324 C 题解","content":"这一道题可以说把我的思维弄得乱七八糟，想出来正解后感觉自己实在是太蠢了。 题面 英文题面 上链接：https://codeforces.com/contest/1324/problem/C 中文题面 现在河面上有 n+2n+2n+2 块石头，编号 000 到 n+1n+1n+1，1 n1~n1 n块石头每块上有一个方向，如果是 L，那么青蛙到这块石头上之后只能往左跳，如果是 R 只能往右，当然，第 000 块石头的方向是 R。 现在青蛙要从 000 跳到 n+1n+1n+1，请问他应该怎么跳才能让他跳跃过程中跳跃距离最长的最小呢？输出这个距离。 思路 这道题是贪心的题目。我们发现，往左边跳其实并不划算，我们往左边跳的时候，距离就会更远，我们想跳的只是朝向右边的石头。这时候，这道题就很简单了，直接求出所有向右边的石头的坐标差，取其中最大值即可。 代码 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-15 00:06:42 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { ios::sync_with_stdio(false); cin.tie(0); int t; cin&gt;&gt;t; while(t--){ string s; cin&gt;&gt;s; vector&lt;int&gt;v; v.push_back(0); for(int i=0;i&lt;s.size();++i) if(s[i]=='R') v.push_back(i+1); v.push_back(s.size()+1); int maxv=-1; for(int i=1;i&lt;v.size();++i) maxv=max(maxv,v[i]-v[i-1]); cout&lt;&lt;maxv&lt;&lt;endl; } return 0; } ","link":"https://OI-Master.github.io/post/codeforces-contest-1324-c-ti-jie/"},{"title":"Codeforces Contest 1335 D 题解","content":"这可以说是我在这场比赛中看到的最简单的题目。 题面 英文题面 请到 https://codeforces.com/problemset/problem/1335/D 去查看。另外，我告诉你们一个特大消息，我昨天奇迹地上去了主站！ 中文题面 就是给你一个 9×99\\times 99×9 的普通数独，九宫格数独，已经填好的，保证合法。如果你不知道数独的规则，可以到 这里 查看，也是我写的。 然后我们需要改变最多 999 个数，是这个数独变成一个 Anti-Sudoku ，它的意思是，每行每列每宫中至少有两个数相等。 输入一个数独，输出你改的 Anti-Sudoku ，如果有多种解， You can print any。 你需要回答 ttt 组数据。 思路 根据我的小研究，我们只需要把所有的 111 改成 222 即可。 为什么这样子就可以？因为，这个原来的数独就是一个满足九宫格数独的要求，就是说每行、每列、每宫都没有重复，那么改一下 111，可以保证行至少有 222 个 222 （原来的一个加上现在新改的一个），每列也会发生重复（原来的一个再加上现在新改的一个），每宫也是一样，所以能保证符合题目 Anti-Sudoku 的要求。 我觉得这种方法最简单，不过 dalao 们改一些特定坐标的方法我也是同意的，不过觉得我这种做法更方便，毕竟思维难度、代码难度都低了嘛。 代码 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-13 15:08:09 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { ios::sync_with_stdio(false); cin.tie(0); int t; cin&gt;&gt;t; while(t--){ for(int i=0;i&lt;9;++i){ for(int j=0;j&lt;9;++j){ char c; cin&gt;&gt;c; if(c=='1') cout&lt;&lt;2; else cout&lt;&lt;c; } cout&lt;&lt;endl; } } return 0; } 为什么感觉题目与思路的比例不对？？？ ","link":"https://OI-Master.github.io/post/codeforces-contest-1335-d-ti-jie/"},{"title":"Codeforces 上创建 Mashup 比赛","content":"公开比赛必须要蓝名才能创建哦！Mashup 是私人比赛。 步骤 那，我们就开始了。 首先，进入 Codeforces主站 。由于我上不去所以就用 https://codeforc.es，步骤一样。 接下来，点击GYM。 然后点击MASHUPS。 然后 Create new mashup。 输入标题等信息。如果需要将一场比赛完全复制进入 Mashup，可以点击 Clone Contest 。不过如果不要的话就别选（反正我一般不点）。 然后可以看到这样子的画面： 发公告，回答问题。 添加题目，在 PROBLEMSET 里找题目。 进入 admin 页面。 编辑比赛（由于选项太多我就解释几个，不解释全部了）。 邀请大家，输入用户名或者生成链接。 其他。 比赛时当您开启管理模式时，可以查看所有人代码，没有开启的话，CF会将您看待为普通参赛者。 ","link":"https://OI-Master.github.io/post/codeforces-shang-chuang-jian-mashup-bi-sai/"},{"title":"Codeforces Contest 1099 C 题解","content":"我又来写题解了！ 题面 英文题面 链接在 这里 ，自己进去看。 中文题面 翻译如下： Description 给定一个长度为 nnn 的字符串，尽可能包含小写字母，字符 ? 和字符 *。保证上面两种特殊字符若出现则一定出现在一个小写字母的后面一位。要求构造一个长度为 kkk 的新字符串，它和原串有如下关系： 按照原串的字母顺序向新串中填充，新串中含且仅含小写字母。 若原串的某小写字母后没有特殊字符，则这个字母在新串中必须保留。 若原串的某小写字母后有字符 ?，则这个字母在新串中可以被保留，也可以被删除。 若原串某小写字母后有字符 *，则这个字母在新串中可以被保留，可以被删除，也可以被复读很多遍。 Input 第一行是一个长度为 nnn 的字符串，保证输入合法； 第二行是一个整数 kkk 代表要求构造的新串长度。 Output 输出一行一个长度为 kkk 的字符串，为构造出的串。 若不存在这样的串，输出 Impossible。 Hint 1≤n,k≤2001\\leq n,k\\leq 2001≤n,k≤200 translated by 一扶苏一 思路 这是一道经典的模拟。 由于宏观简单，我们就看微观了。 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-11 03:33:32 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { ios::sync_with_stdio(false); cin.tie(0); 毫无质量的东西，这些是板子。 string s; int k; cin&gt;&gt;s&gt;&gt;k; 毫无质量的东西，这些是输入。 int sum=0; for(int i=0;i&lt;s.size();++i) if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') ++sum; else if(s[i]=='*'){ sum=10000000000000; break; } if(sum&lt;k){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; return 0; } 毫无质量的东西，这些是循环。 才怪呢，我们发现，只要是字母都把它加上去，如果是 * 就说明能重复无数次。 原来是看最大能到多少。 sum=0; for(int i=0;i&lt;s.size();++i) if(s[i]=='?'||s[i]=='*') --sum; else ++sum; if(sum&gt;k){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; return 0; } 毫无质量的东西，这些也是循环。 我们再来看看这是什么用的。 我们发现，当 sis_isi​ 是字母的话，那么 sumsumsum 加 111 ，如果是字符，就让 sumsumsum 扣掉 111。 发现，我们算的东西就是最少长度是多少，只要一个字母后面有 * 或者是 ? 的话，就不算这个字母（删掉）。 最后比较一下。 vector&lt;char&gt;ans; for(int i=1;i&lt;s.size();++i) if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'&amp;&amp;s[i-1]&gt;='a'&amp;&amp;s[i-1]&lt;='z') ans.push_back(s[i-1]); else if(s[i]=='?'&amp;&amp;sum&lt;k){ ++sum; ans.push_back(s[i-1]); } else if(s[i]=='*'&amp;&amp;sum&lt;k) while(sum&lt;k){ ++sum; ans.push_back(s[i-1]); } 核心部分啦！ 如果这个字符是字母，不是符号，前面一个也不是符号，那么就说明前面一个必须要选，进 ansansans 里面。 否则，如果是问号的话，并且串长不够，那么就把字母压到 ansansans 里。 如果是 * 的话，那么可以把串长补到够，一直加，没有副作用。 这一段我故意写得稍微有些简洁，想让大家再看几下代码，好好理解。 if(s[s.size()-1]&gt;='a'&amp;&amp;s[s.size()-1]&lt;='z') ans.push_back(s[s.size()-1]); for(int i=0;i&lt;ans.size();++i) cout&lt;&lt;ans[i]; return 0; } 这一段好像的确没什么难的了，就是打印。 代码 完整代码如下： /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-11 03:33:32 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { ios::sync_with_stdio(false); cin.tie(0); string s; int k; cin&gt;&gt;s&gt;&gt;k; int sum=0; for(int i=0;i&lt;s.size();++i) if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') ++sum; else if(s[i]=='*'){ sum=10000000000000; break; } if(sum&lt;k){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; return 0; } sum=0; for(int i=0;i&lt;s.size();++i) if(s[i]=='?'||s[i]=='*') --sum; else ++sum; if(sum&gt;k){ cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; return 0; } vector&lt;char&gt;ans; for(int i=1;i&lt;s.size();++i) if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'&amp;&amp;s[i-1]&gt;='a'&amp;&amp;s[i-1]&lt;='z') ans.push_back(s[i-1]); else if(s[i]=='?'&amp;&amp;sum&lt;k){ ++sum; ans.push_back(s[i-1]); } else if(s[i]=='*'&amp;&amp;sum&lt;k) while(sum&lt;k){ ++sum; ans.push_back(s[i-1]); } if(s[s.size()-1]&gt;='a'&amp;&amp;s[s.size()-1]&lt;='z') ans.push_back(s[s.size()-1]); for(int i=0;i&lt;ans.size();++i) cout&lt;&lt;ans[i]; return 0; } ","link":"https://OI-Master.github.io/post/codeforces-contest-1099-c-ti-jie/"},{"title":"Codeforces Contest 1134 C 题解","content":"这一道题我昨天晚上做了很久，不过最后居然 AC 了。貌似大家都没有 AC 呀，我写一篇题解吧。 题面 英文题面 为什么要给呢，直接去 这里 就好了啊。 中文题面 有 NNN 头凶猛的怪兽，他们围成一个圈圈，顺时针编号 1,2,3,4,…,N1, 2, 3, 4, \\dots , N1,2,3,4,…,N 每一头怪兽都有 222 个属性——一个是它的生命值，第二个是它的爆炸值。爆炸会发生在它生命值小于等于 000，就是说他死掉的时候，它的下一头怪兽会遭到 它的爆炸值 点伤害。如果下一头怪兽已经死了，则无伤害。如果这回又把下一头怪兽给弄死了，那么下一头怪兽也会爆炸，连环炸到下下头怪兽……你还有一把枪，每发子弹可以伤害一头怪兽的生命值 111 点。问你，把怪兽都炸掉，要用多少子弹。 思路 我们知道，打掉怪兽有 222 种可能。第一种，就是专门拿枪一发一发地打它，一种是先打 这个怪兽的生命值-上个怪兽的爆炸值 发，也就是说，最后让上一个怪兽把它爆掉。我们发现，不管怎么打， “这个怪兽的生命值-上个怪兽的爆炸值 发”肯定是要的，于是我们先打这么多发。 这时候，又出现了一个情况。我们发现，在怪兽中间，出现了一个“环”，只要有一个怪兽死了，大家都会被连环炸掉。所以，我们只需要打死现在生命值最小的怪兽即可。 代码 别抄袭啊！ /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-10 15:45:27 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long struct node{ int h; int b; int c; }; signed main() { ios::sync_with_stdio(false); cin.tie(0); int t; cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; node a[n]; for(int i=0;i&lt;n;++i) cin&gt;&gt;a[i].h&gt;&gt;a[i].b; if(n==1){ cout&lt;&lt;a[0].h&lt;&lt;endl; continue; } a[0].c=a[0].h-a[n-1].b; for(int i=1;i&lt;n;++i) a[i].c=a[i].h-a[i-1].b; int sum=0; for(int i=0;i&lt;n;++i) if(a[i].c&gt;0){ sum+=a[i].c; a[i].h-=a[i].c; } int minv=1000000000000; for(int i=0;i&lt;n;++i) minv=min(minv,a[i].h); cout&lt;&lt;sum+minv&lt;&lt;endl; } return 0; } ","link":"https://OI-Master.github.io/post/codeforces-contest-1134-c-ti-jie/"},{"title":"算法脑图","content":"图片来源于网络，侵权删。 ","link":"https://OI-Master.github.io/post/suan-fa-nao-tu/"},{"title":"Codeforces Contest 1102 B 题解","content":"我又来写题解了，呵呵呵，最近沉迷于刷题、写题解，无法自拔…… 好了，不说别的了，现在快点进入正题。 题面 英文题面 这里从来不会出现英文题面的好吗，需要你去 这里 看的。 中文题面 写完今早的题解后，我想了想，决定还是把题目的意思放出来，能节约大家的时间。 给出一个长为 nnn 的序列 aaa 和 kkk 种颜色,用这 kkk 种颜色给 aaa 中的元素染色，要求： 每个元素都要被染色 每种颜色都要被使用 每种颜色不会被用于相同的元素（即若颜色 ci=cj(i≠j)c_i = c_j(i \\neq j)ci​=cj​(i​=j) ，必须保证 ai≠aja_i \\neq a_jai​​=aj​） 如果没有可行的方案，输出 NO ,否则输出 YES 和任何一种可行的方案。 思路 首先先膜拜一下大佬 xyf007 ，他写的这篇洛谷题解引发了我的思路（虚拟赛后看见的，大家别以为我作弊），然后我想了想，决定写一下这篇题解。 我们这道题的确完全不用各种各样的高级算法，什么桶排序、什么双指针、什么vis数组，都不要，我们只要结构体，一个变量 num ，就可以做了。 如果 n&lt;kn&lt;kn&lt;k 的话，肯定用不完所有的数字，输出 −1-1−1。 我们首先判断是否有数字出现次数 &gt;k&gt;k&gt;k ，如果有，那么一定不行的。 如果没有，那么一定行。我们像这样填色。 先将数组按照大小排序 然后让一个变量 num 来从 111 到 kkk 循环，到了 k+1k+1k+1 就把它赋值为 111。 轮流填， num 是多少就填多少。 想想，为什么这样子可以？ 然后就十分简单，我们按照原始数列的编号排个序，输出即可。 代码 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-07 11:06:01 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long struct node{ int id,val,b; }; bool cmp1(node x,node y){ return x.val&lt;y.val; } bool cmp2(node x,node y){ return x.id&lt;y.id; } signed main() { ios::sync_with_stdio(false); cin.tie(0); int n,k; cin&gt;&gt;n&gt;&gt;k; if(n&lt;k){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; } node a[n]; int b[5001]; for(int i=1;i&lt;=5000;++i) b[i]=0; for(int i=0;i&lt;n;++i){ a[i].id=i; cin&gt;&gt;a[i].val; ++b[a[i].val]; if(b[a[i].val]&gt;k){ cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; } } sort(a,a+n,cmp1); int num=1; for(int i=0;i&lt;n;++i){ a[i].b=num; ++num; if(num==k+1) num=1; } sort(a,a+n,cmp2); cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; for(int i=0;i&lt;n;++i) cout&lt;&lt;a[i].b&lt;&lt;' '; return 0; } ","link":"https://OI-Master.github.io/post/codeforces-contest-1102-b-ti-jie/"},{"title":"Codeforces Contest 1010 B & 1011 D 题解","content":"不出你的意料，今天我又来写题解了（你可能会问我为什么还没有开学）。这一次我写的题解是一道交互题的题解，毕竟是第一次写这种交互题的题解，写得不太好请大家别太在意，您可以在评论区来留言，我会根据你的留言来完善一下本篇题解或是下一篇题解。 好的，我们仍然按照老配方，题面先。 题面 英文题面 如果你以前看过我写 Codeforces 的题解，你应该很清楚， 这里会挂个链接，而不会写题面。 中文题面 请去 洛谷站内 了解。嘿，有点过分，上次是直接复制洛谷的翻译，这次只给个链接？！是的，没错，翻译的很好，“抽风”这个词十分得恰当。 思路 省掉了题面，这一篇文章短多了。我们首先假设，火箭不会抽风，那么你会怎么做？很显然，我们可以二分一下这个值，每次输出 midmidmid ，看一下交互器的相应。 但是，事实上没有这么好，火箭随时可能抽风，那么假设我们知道抽风的序列 ppp ，那么是不是这一道题也很简单？我们看见本轮火箭要抽风了，我们就把火箭的答案反转一下，也可以二分。 问题是，现在我们并不知道 ppp ，那么怎么搞？等等，我们先放着。 我们可以先了解一下，二分至 10910^9109 要多少次。我们用 Python 求一下吧。 tmp=1 tot=0 while tmp&lt;1000000000 : tot+=1 tmp*=2 print(tot) 输出了 303030，这时候我们貌似想到了什么…… 我们惊讶地发现，火箭抽风的周期也是 303030 ，加起来就是 606060 次！ 那么很显然，我们可以拿前 303030 次来确定火箭抽风的序列，然后把后 303030 次用来二分。这个想法实在是太好了！ 还有，我们前 303030 次怎么确定？其实我们只需要一直输出 111 就可以了，如果它输出 111 ，那么本轮就不会抽风，如果是 −1-1−1 ，那么就说明会抽风，如果是 000 ，那么数据太巧，要特判。 然后，就是可爱的代码啦。 代码 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-07 07:13:12 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { ios::sync_with_stdio(false); cin.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; int a[m+1],tmp; for(int i=1;i&lt;=m;++i){ cout&lt;&lt;1&lt;&lt;endl; cout.flush(); cin&gt;&gt;tmp; if(tmp==0) return 0; if(tmp==-2) return 0; if(tmp==1) a[i]=1; else a[i]=0; } int left=2; int right=n; int mid; int mod=0; while(left&lt;=right){ ++mod; if(mod==m+1) mod=1; mid=(left+right)/2; cout&lt;&lt;mid&lt;&lt;endl; cout.flush(); cin&gt;&gt;tmp; if(tmp==0) return 0; if(tmp==-2) return 0; if(a[mod]==0) tmp=-tmp; if(tmp==1) left=mid+1; else right=mid-1; return 0; } ","link":"https://OI-Master.github.io/post/codeforces-contest-1010-b-and-1011-d-ti-jie/"},{"title":"Codeforces Contest 262 B 题解","content":"这道题是我下午做的，你在源代码里的 Time 就会发现。是的，没错，不过晚上我还要打一场虚拟。 貌似这道题洛谷没人写题解呀，我就把这个坑填上吧。 题面 英文题面 请去 Codeforces 官网上看吧，我这里不做介绍 中文题面 一个人要统计他所在公司的总收入并且他想使总收入达到最大，收入写在一条清单上，总收入是清单上所有数之和。 他有 mmm 次操作的机会，每次操作可以将某个数一个数变成其相反数，例如 111 变成 −1-1−1 （注意，他必须严格执行 mmm 次）问总收入最大是多少？（作弊啊，同志 思路 简单水题，瞬间秒杀！ 这道题的确很水的好不好，可是弱弱的我就因为一个小错误 WA 了 333 次，唉。 这道题由于是到简单题，所以我决定从微观开始讲。 首先是板子 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-06 16:45:57 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { ios::sync_with_stdio(false); cin.tie(0); 呵呵呵，板子有点长，接下来是简单得不能再简单的输入。 int n,m; cin&gt;&gt;n&gt;&gt;m; int a[n]; for(int i=0;i&lt;n;++i) cin&gt;&gt;a[i]; 这种题目，显然要排序。 sort(a,a+n); 然后呢，我们就要详细地讲一下这一段。 int j=0; while(a[j]&lt;0&amp;&amp;m&gt;0){ a[j]*=-1; --m; ++j; } if(a[j]==0) m=0; 怎么解释？我们先看 jjj ，大家应该都知道 jjj 是什么意思吧，就是说现在看到第几个了。你可能会问，为什么不用 iii ，因为我习惯把 iii 作为 for 循环的变量，如果定义 iii 的话，将会编译错误。当你看到完整代码的时候，你就会知道为什么要用 jjj 而不用 iii 。 然后我们先不扯 iii 和 jjj 的问题，就看中间这一段。如果你不会做这道题的话，我觉得对于这一段的问题还是挺大的。 我们大概能通过字面意思了解到，这一段话的作用就是把所有 ≤0\\leq 0≤0 的数字中前 kkk 小的挑出来（当然如果没有 kkk 这么多就是全挑出来），乘上一个 −1-1−1 ，相当于负的变成正的。如果有多的，那么后面在应用于正数上。 那么后面的 if 语句又是怎么回事？其实，我们发现， 000 是一个神奇的数字，当我们搞到 000 的时候，我们可以搞任意多次，把 mmm 耗光，就不用搞到正数上面了，搞到正数上面可能还会起到副作用。 好，那么接下来，我们就要处理一下当 mmm 还没用完的情况了。 还是上代码。 sort(a,a+n); if(m&amp;1) a[0]*=-1; 首先，先排序。 然后，我们发现，当 mmm 是偶数的时候，我们可以把 mmm 用在一个数字上，会抵消，所以没用。 如果是奇数的话，我们又会发现，操作在最小的数字上最划算，而且操作完后相当于动一下（因为偶数就抵消了），所以就可以直接放心地把 a0a_0a0​ 乘上 −1-1−1。 int sum=0; for(int i=0;i&lt;n;++i) sum+=a[i]; cout&lt;&lt;sum&lt;&lt;endl; return 0; } 这些有什么好看的 代码 我已经把所有的代码都展示出来了，大家自己拼吧（逃 ","link":"https://OI-Master.github.io/post/codeforces-contest-262-b-ti-jie/"},{"title":"Atcoder ABC 160 E 题解","content":"首先，感谢大佬 hhhyyyfff 和他的程序，它们开导了我的思路。好了，现在开始正题了，先讲一下题面。 题面 英文题面 请你点 这里，会带你去 AtCoder 的官网。 中文题面 你们将吃 XXX 个红苹果和 YYY 个青苹果。 你有 AAA 个美味的红苹果 p1,p2,...,pAp_1,p_2,...,p_Ap1​,p2​,...,pA​，BBB 个美味的青苹果 q1,q2,...,qBq_1,q_2,...,q_Bq1​,q2​,...,qB​ 和 CCC 个无色美味的苹果 r1,r2,...,rCr_1,r_2,...,r_Cr1​,r2​,...,rC​。 在吃无色苹果之前，你可以把它涂成红色或绿色，它将分别算作红色或青色苹果。 从上面的苹果中，你可以选择要吃的苹果，同时把吃过的苹果的美味之和尽可能地做大。 找出将零个或更多无色苹果进行最佳着色时所能达到的吃掉苹果美味的最大可能总和。 输入格式大家自己看吧，我不翻译了。 思路 这道题比 D 题简单，不过比赛的时候没出来……其实就是一个大根堆，来维护一下所有的苹果的美味程度，同时记录下来这个苹果的颜色。然后，每次把堆顶拿出来。如果堆顶是一个红色苹果，且还没有吃到 XXX 个红苹果，那么就吃！如果堆顶是一个青色苹果，且还没有吃到 XXX 个青苹果，还是马上就吃！如果是一个无色的苹果，先不计数，然后将剩下的总数减掉一。当然，吃有颜色的苹果时，也要将 XXX 或者是 YYY 减掉一，同时把苹果的总数也减掉一。我语文很差，但是代码写得还行，所以大家先看代码吧。不理解的可以在评论留言。 代码 那么，就上代码啦。 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; #define int long long signed main(){ int x,y,a,b,c; cin&gt;&gt;x&gt;&gt;y&gt;&gt;a&gt;&gt;b&gt;&gt;c; priority_queue&lt;pair&lt;int,int&gt; &gt;h; while(a--){ int w; cin&gt;&gt;w; h.push(make_pair(w,1)); } while(b--){ int w; cin&gt;&gt;w; h.push(make_pair(w,2)); } while(c--){ int w; cin&gt;&gt;w; h.push(make_pair(w,3)); } int z=x+y; int ans=0; while(z){ pair&lt;int,int&gt;f=h.top(); h.pop(); if(f.second==3){ ans+=f.first; --z; } else if(f.second==1&amp;&amp;x){ ans+=f.first; --x; --z; } else if(f.second==2&amp;&amp;y){ ans+=f.first; --y; --z; } } cout&lt;&lt;ans&lt;&lt;endl; return 0; } 本文到此结束，谢谢您的观看。 ","link":"https://OI-Master.github.io/post/atcoder-abc-160-e-ti-jie/"},{"title":"Codeforces Contest 32 D 题解","content":"早上六点打的虚拟比赛，差点 AK ，就差一个 E 题。最后发现 E 题不论是 洛谷 还是 Codeforces 都没有题解，而看 CF 正确的源代码又看不懂，我太难了…… 题面请在洛谷里看，我这里不做介绍。 我们先讲思路吧。 思路 NNN 才 300300300 ？那就写个 O(N3)O(N^3)O(N3) 算法。啪啪啪啪啪啪啪啪……咦？居然过 了？！ 这道题的数据很小呢，所以发现这道题纯考你的手熟不熟，思维不难。 我们先枚举半径（ rrr ，从小到大），然后枚举行（ iii ，从小到大），再枚举列（ jjj ，还是从小到大），然后我们每次判断存不存在当中心点为 (i,j)(i, j)(i,j)，半径为 rrr 的十字形星座。如果有，那么就把总数加上 111 。如果总数到了 KKK，那么我们就打印。 如果最后啥也没打出来（也就是说，总数小于 KKK），那么就输出 −1-1−1。 如此简单，这上面就算是一种伪代码了（难道不是吗？ 代码 给上 C++ 实现的代码 /* Generated by powerful Codeforces Tool * Author: OI_Master * Time: 2020-03-31 07:20:10 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; char c[n+1][m+1]; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) cin&gt;&gt;c[i][j]; int num=0; for(int r=1;r&lt;=min(n,m);++r) for(int i=r+1;i+r&lt;=n;++i) for(int j=r+1;j+r&lt;=m;++j) if(c[i][j]=='*'&amp;&amp;c[i-r][j]=='*'&amp;&amp;c[i+r][j]=='*'&amp;&amp;c[i][j-r]=='*'&amp;&amp;c[i][j+r]=='*'){ if(num==k-1){ cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl&lt;&lt;i-r&lt;&lt;' '&lt;&lt;j&lt;&lt;endl&lt;&lt;i+r&lt;&lt;' '&lt;&lt;j&lt;&lt;endl&lt;&lt;i&lt;&lt;' '&lt;&lt;j-r&lt;&lt;endl&lt;&lt;i&lt;&lt;' '&lt;&lt;j+r&lt;&lt;endl; return 0; } else ++num; } cout&lt;&lt;-1&lt;&lt;endl; return 0; } 本文到此结束。 ","link":"https://OI-Master.github.io/post/codeforces-contest-32-d-ti-jie/"},{"title":"Codeforces Contest 132 C 题解","content":"仍然是老习惯，早上起床打一场 Codeforces。今天起晚了，打不起来，所以就做了一道 C 题。我是拿随机数跳题跳的，爬取题面到本地以后一直在做，调了好久，感到奇怪，最后交的时候才发现这是 Div.1 （唔，问题是我居然 AC 了？ 好啦，我们先讲题面。 题面 英文题面 既然是英文的我为什么要给呢，你自己去 Codeforces 上面看吧。 中文题面 复制一下洛谷上的翻译（我啥时候变得如此懒了 很多人把 Logo 编程语言和海龟图形联系起来。在这种情况下，海龟沿着直线移动，接受命令 T （转 180180180 度）和 F （向前移动 111 单元）。 你会收到一份给海龟的命令清单。你必须从列表中精确地改变 NNN 个命令（一个命令可以被改变多次）。要求出海龟在遵循修改后的所有命令后，会从起点最远可以移到多远？ 思路 典型的 DP 题目。我们可以用一个三维 DP 来做这道题目，是 dpi,j,kdp_{i,j,k}dpi,j,k​ ，表示的是前 iii 个字符，换了 jjj 次，然后方向为 kkk 的时候里原点最大的距离。kkk 的取值为 000 或者是 111 ，000标识的就是正方向，111 表示的就是负方向。 然后，我们来分析一下状态转移方程，不过，直接写不太方便，我觉得我们应该从每个情况看起。 如果 sis_isi​ 是 F： 我们枚举在这个 iii 的位置上换了几次，枚举的范围就是 000 至 jjj，然后我们把这个换的次数的值叫做 kkk ，接下来我们再进一步分析一下 kkk。 如果 kkk 是奇数的话，那么因为抵消的关系就相当于 kkk 是 111 。那么，现在的方向一定和上一次的方向是相反的，所以，可以得知，状态转移方程如下：dpi,j,0=max(dpi,j,0,dpi−1,j−k,1)dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,1}) dpi,j,0​=max(dpi,j,0​,dpi−1,j−k,1​) 然后，我们也可以得知dpi,j,1=max(dpi,j,1,dpi−1,j−k,0)dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,0}) dpi,j,1​=max(dpi,j,1​,dpi−1,j−k,0​) 否则，那么 kkk 就是偶数，那么就等于字符没变呢。所以，我们就按照现在的方向向前走一步，如果是正方向，那么位置就加上 111 。如果是负方向，那么位置就减掉 111 。这个应该很好理解，上式子。dpi,j,0=max(dpi,j,0,dpi−1,j−k,0+1)dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,0}+1) dpi,j,0​=max(dpi,j,0​,dpi−1,j−k,0​+1) 几乎一样的式子：dpi,j,1=max(dpi,j,1,dpi−1,j−k,1−1)dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,1}-1) dpi,j,1​=max(dpi,j,1​,dpi−1,j−k,1​−1) 是吧？很好理解对不对？ 如果 sis_isi​ 是字符 T： 额，一样的一样的，如果 kkk 是奇数的话，那么 sis_isi​ 就会变成 F ，状态转移方程搬下来：dpi,j,0=max(dpi,j,0,dpi−1,j−k,0+1)dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,0}+1) dpi,j,0​=max(dpi,j,0​,dpi−1,j−k,0​+1) dpi,j,1=max(dpi,j,1,dpi−1,j−k,1−1)dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,1}-1) dpi,j,1​=max(dpi,j,1​,dpi−1,j−k,1​−1) 如果 kkk 是偶数的话：dpi,j,0=max(dpi,j,0,dpi−1,j−k,1)dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,1}) dpi,j,0​=max(dpi,j,0​,dpi−1,j−k,1​) dpi,j,1=max(dpi,j,1,dpi−1,j−k,0)dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,0}) dpi,j,1​=max(dpi,j,1​,dpi−1,j−k,0​) 好了，现在是不是感觉很简单？我们只需要加一个简单的初始化即可。 dp0,0,0=dp0,0,1=0dp_{0,0,0}=dp_{0,0,1}=0 dp0,0,0​=dp0,0,1​=0 其他的格子都赋值为无限小（−inf-inf−inf）。 上代码。 代码 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-06 08:37:08 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int dp[101][51][2]; signed main() { ios::sync_with_stdio(false); cin.tie(0); string s; cin&gt;&gt;s; int n; cin&gt;&gt;n; int size=s.size(); s=' '+s; for(int i=0;i&lt;=size;++i) for(int j=0;j&lt;=n;++j) dp[i][j][0]=dp[i][j][1]=-1000000000000; dp[0][0][0]=0; dp[0][0][1]=0; for(int i=1;i&lt;=size;++i) for(int j=0;j&lt;=n;++j) for(int k=0;k&lt;=j;++k) if(s[i]=='F') if(k%2==1){ dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][0]); dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][0]); } else{ dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][0]+1); dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][1]-1); } else if(k%2==1){ dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][0]+1); dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][1]-1); } else{ dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][1]); dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][0]); } cout&lt;&lt;max(dp[size][n][0],dp[size][n][1]); return 0; } 没了，没了，下面就是评论区了。 ","link":"https://OI-Master.github.io/post/codeforces-contest-132-c-ti-jie/"},{"title":"Codeforces Contest 1095 D 题解","content":"为了纪念马上开学，我又来写题解了。早上六点仍然打了一场虚拟比赛，不过没人陪我啊（如果您可以请告诉我，我的 QQ 号是 202367038，谢谢。 然后呢，我就不扯别的了，先开始正题，不过在说思路之前，我们得讲讲题面。 题面 英文题面 这道题的英文题面可以在 Codeforces 上找到，这里不多说，实在是没有必要把英文题面拷贝过来。其实也没有访问的必要，主要是告诉你可以在哪里提交。 中文题面 一群小孩在一起玩游戏，他们围成一个圈圈，就像是这样。 小孩是每个小节点，边（箭头）就是表示小孩面向的方向。 然后接下来，小孩子们被打乱，找不到原来的顺序了。但是唯一一个好处就是，他知道他前面的人和前面的前面的人。注意，给的时候可能没按照顺序给，例如先告诉你“前面的前面”的小孩子的编号，再告诉你“前面”得人的编号，需要你自己判断。 我们告诉你这些小孩子们的回忆，让你还原小孩子们原来的位置，例如，这张图的答案就是 [3,2,4,1,5][3,2,4,1,5][3,2,4,1,5] ，也可以说是 [1,5,3,2,4][1,5,3,2,4][1,5,3,2,4]，还有别的答案，你输出任意一种即可。 如果你没看懂，请在评论留言，我会根据你的问题进一步修改文章的翻译。 思路 这道题我们会发现这些条件给的并不好，我们没法确定相邻的信息，因为我们给的时候不知道两个数字的顺序，自然也无法判断到底是哪一个数字跟我相邻。不过，我们可以转个弯，如果 aaa 和 bbb 一个是我的前面，一个是我前面的前面，那么很显然，aaa 与 bbb 相邻。我们构造一个这样子的图就行了。 我写呀写、写呀写、写呀写、写呀写，唉，最后还是答案错误，您一定知道这是什么意思吧？我最后发现了一个 Bug ，就是我们可能把整个图搞反了，箭头的方向走错了，怎么办呢？ 很简单，我们只需要在第一个数字读入的时候，记录下两个数字的位置，在第一次走的时候不要走反方向，要向这两个数字走。 于是，代码写出来了。 于是，我 AC 了此题。 于是，我就放代码了。 （皮一下很开心 代码 /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: OI_Master * Time: 2020-04-05 07:16:11 **/ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int head[200300]; int cnt; struct edge{ int next; int to; }e[400300]; void add_edge(int u,int v){ ++cnt; e[cnt].next=head[u]; head[u]=cnt; e[cnt].to=v; } bool vis[200300]; void dfs(int s){ cout&lt;&lt;s&lt;&lt;' '; vis[s]=true; for(int i=head[s];i;i=e[i].next) if(vis[e[i].to]==false){ dfs(e[i].to); break; } } signed main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; int a,b; for(int i=1;i&lt;=n;++i){ int x; int y; cin&gt;&gt;x&gt;&gt;y; add_edge(x,y); add_edge(y,x); if(i==1){ a=x; b=y; } } cout&lt;&lt;&quot;1 &quot;; vis[1]=true; for(int i=head[1];i;i=e[i].next) if(e[i].to==a||e[i].to==b){ dfs(e[i].to); break; } return 0; } 好，本文到此结束。 ","link":"https://OI-Master.github.io/post/codeforces-contest-1095-d-ti-jie/"},{"title":"搭建自己的 Online Judge","content":"很多人对于做题有点厌烦，但是，如果让你出题给别人做那么可能会很有意思。可是，出题只能出在一些别人的 OJ 上，甚至只能在自己的 Word 文档里出。今天我教大家一个厉害点的，叫做搭建自己的 Online Judge ！ 准备 额，当然是一台服务器啦，我们要一个无操作系统、纯净的服务器。如果你实在是买不起像我一样，那么就可以在虚拟机上搭建。 注意，必须为 646464 位。如果你是虚拟机搭建，请保证要安装虚拟机的系统是 646464 位系统。我们后面的操作都必须在 646464 位系统下进行。 有云服务器的请自行跳过这一段。 你需要在本机创建一个虚拟机，我推荐VMware Workstation Player 15，它的操作十分简单易学，更重要的的是，它是免费软件。 点击此处下载：VMware Workstation Player 15 ，并安装好。 下载完成后，请继续阅读下面一段。 接下来我们就要进行操作系统的安装了。 我们要下载Ubuntu 16.04.6 (amd64, Desktop LiveDVD)，但是在官网下实在是太慢了。我挂了一个清华大学开源软件镜像站的镜像下载链接：Ubuntu 16.04.6 (amd64, Desktop LiveDVD) 如果你用的是服务器，现在在你的服务器上装系统吧。 用虚拟机的，请打开这个软件。如果你是第一次打开，请选择“免费将……用于非商业用途”。 打开了吧？现在看见左边那一栏了吗？选择“新建虚拟机”，会弹出一个窗口，选择第二个选项，然后路径找到刚刚下载下来的 iso 文件，点击下一步。 接下来，请输入 OJ 的电脑全名和用户名密码。全名可以随便起（中文除外），但是用户名只能为小写字母，不能为 root 。 然后回让你确定虚拟机的名称。建议把它放在一个空间充足的盘里。 它又会让你设置磁盘容量。很多人看到 202020 GB 这个大数会打个疙瘩，以为这样会很快把磁盘消耗完毕。其实操作完后它并不会在磁盘里创建一个 202020 GB 的文件，而是通过需求慢慢增长。换句话说，这就是你对虚拟机的容量最大上限。 如果弹出了一个选项框询问是否安装“VMware Tools for Linux”，请选择“下载并安装”。 等待 151515 分钟-？天，虚拟机的系统装好了。 搭OJ 赶紧撸起袖子，现在已经到高潮部分了！ 由于 Ubuntu 系统自带的源是国外的的源，所以当我们安装软件时，下载的速度会非常慢。因此，我们需要更改系统源为国内的源。如果你不知道什么叫“源”，也不用担心，就按照我说的做就行了。 点击右上角的齿轮按钮，选择“System Settings”。在随后弹出的界面中，选择“Software &amp; Updates”。请在弹出的窗口中将“Download from”改为“Other”。然后请选择“China”中的“mirrors.ustc.edu.cn”。输入密码就可以了。当你点击右下角的“Close”按键退出时，系统会弹出一个窗口。请点击“Reload”。这样，我们就成功地将源切换为中科大源了。当然，如果有的源离你更近，我也不拒绝换成其他的源，或不换。我这么做只是为了节约您的生命。 请在正在打OJ的机器中打开此网页，这个网址我相信你会背下来的。 右击桌面，打开终端（Open Terminal），将下面的命令拷在里面。 sudo su 然后会让你输入密码。你只需要输就行了。注意，这回不想登录界面会给你显示“输入进去”的“*”，而是什么都不显示。你是看不到你输入的密码的，只要踏踏实实的输进去就行了。 然后请把下面的命令复制一下。 cd / apt update &amp;&amp; sudo apt install -y vim python-pip curl git 等到这个操作完成了，再输入下面的代码。 curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 然后再等待系统完成，输入一条 chmod +x /usr/local/bin/docker-compose 好了，依赖已经安装完成了！ 不过只是依赖装完了，还没有到正事呢！我们先安装一下 Docker 。 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 不过，这还是很慢，所以我们在配置一下加速器。 gedit /etc/docker/daemon.json 把一下的东西拷到弹出的窗口中。 { &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;] } 注意，不能直接叉掉，一定要先保存啊！ 现在，我们可以正式的装 OJ 了。我们这回装的可不是那个经典的 HUSTOJ ，因为它的 UI 设计实在是太恶心了。我们用青岛大学的 Qduoj 。这个 OJ 又好看又简洁还实用，唯一的缺点就是没法用 Pascal。请学 Pascal 的同学赶紧转到 C++ 吧！ 请在终端中拷入 gedit /etc/hosts 在弹出的窗口中末尾加入 151.101.72.249 github.global.ssl.fastly.net 192.30.253.112 github.com 你能猜到，我们又在配置 Github 的加速器了。 现在，我们要拉取文件 git clone -b 2.0 https://github.com/QingdaoU/OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy 最后一步了！！！ docker-compose up -d 等待一会儿，看见四个 Done 的时候，就说明，你的 OJ 大功告成了！ 打开OJ 如果你用的是服务器，输入你的服务器的 公网IP 就行了。如果你用的是虚拟机，打开火狐浏览器，输入 127.0.0.1 就可以看到你的 OJ 了。如果没有，请多刷几遍，如果刷了半个小时还没有，那么就是装失败了。 点击右上角的“ Login ”，登录初始管理员账户。 账号：root 密码：rootroot 登陆后点击右上角的 root ，选择“ Setting ”就可以设置语言、昵称等信息。记得，一定要及时改 root 密码！随后的设置，就留给你自己去探索吧。 结语 感谢中国科学技术大学开源软件镜像站、DaoCloud、阿里巴巴开源镜像站和清华大学开源软件镜像站，没有他们的镜像服务，我们不可能得到如此稳定的连接，也不可能如此简单快捷地完成部署过程。 Qduoj的官方参考文档可以登陆： https://docs.onlinejudge.me/#/ 查看 如果有实在不会的，请在评论留言，我会加以说明。 ","link":"https://OI-Master.github.io/post/da-jian-zi-ji-de-online-judge/"},{"title":"Codeforces Contest 6 E 题解","content":"今天是我博客建立一个月的日子。为了欢庆这一天，我又来写题解了。 题面 英文题面 上 这里 ， Codeforces 官网，加载太慢不关我事！ 中文题面 本来是我要翻译的，不过 洛谷 是一个很好的社区，这次我不翻译了，大家去 CF6E 来看题目吧！ 思路 这一道题， N≤105N\\leq 10^5N≤105 ，我们知道，这种数据一定是 O(Nlog2N)O(Nlog_2^N)O(Nlog2N​) 的时间复杂度。但是，我们用什么方法呢？排序？二分答案？二叉堆？这样空想是一定不行的，我们要有针对性的想。 我们觉得 logloglog 不太好想，也许只是一个小算法的时间复杂度。我们可以像是“往宏观”走，去想想这道题有没有 O(N)O(N)O(N) 的算法。 我们发现，想要是 O(N)O(N)O(N) 的话，暂时就是“双指针”算法。这个算法是可以的，我来讲一下什么情况下要干嘛。 当 AL,AL+1,...,AR−1,ARA_L, A_L+1, ... , A_R-1, A_RAL​,AL​+1,...,AR​−1,AR​ 不满足条件的时候，我们可以把 L+1L+1L+1 ，这样子，就有可能合法。至于到底合不合法，可以稍后判断。 当 AL,AL+1,...,AR−1,ARA_L, A_L+1, ... , A_R-1, A_RAL​,AL​+1,...,AR​−1,AR​ 合法的时候，也就是满足这个条件后，我们可以先比较一下长度。如果长度比原来存的序列长度长，那么就更新一下长度，把答案数量再改成 111 ，接下来，我们再把 R+1R+1R+1 。如果还是不了解我的意思，可以在评论区留言。 不过，我们如何找到“最大值”与“最小值”呢？大家可以搞个单调队列，不过我在这里推荐 multiset 。不懂的自己查百度。 代码 然后，就是可爱的代码啦！ /* * Generated by powerful Codeforces Tool * Author: OI_Master * Time: 2020-03-24 10:01:05 */ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main(){ ios::sync_with_stdio(false); cin.tie(0); int n,k; cin&gt;&gt;n&gt;&gt;k; multiset&lt;int&gt;m; int j=1; int a[n+1]; int maxs=0; vector&lt;pair&lt;int,int&gt; &gt;ans; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;a[i]; m.insert(a[i]); while(*(m.rbegin())-*(m.begin())&gt;k){ m.erase(m.find(a[j])); ++j; } if(i-j+1&gt;maxs){ ans.clear(); maxs=i-j+1; ans.push_back(make_pair(j,i)); } else if(i-j+1==maxs) ans.push_back(make_pair(j,i)); } cout&lt;&lt;maxs&lt;&lt;' '&lt;&lt;ans.size()&lt;&lt;endl; for(int i=0;i&lt;ans.size();++i) cout&lt;&lt;ans[i].first&lt;&lt;' '&lt;&lt;ans[i].second&lt;&lt;endl; return 0; } ","link":"https://OI-Master.github.io/post/codeforces-contest-6-e-ti-jie/"},{"title":"洛谷试炼场","content":"这是洛谷试炼场的一个备份，大家可以继续练习。 新手村 任何一个伟大的目标，都有一个微不足道的开始。 洛谷的第一个任务 勇敢的迈出第一步，了解下语言和洛谷。跟着书本和老师走，不会难的。 P1000 P1001 P1421 P1425 顺序与分支 计算机的智能性开始得以体现，因为计算机能够根据不同的条件选择了。 P1422 P1085 P1089 P1909 循环！循环！循环！ 计算机最不怕的就是重复。你让它做10000次同样的事它也不怕啦，但是让他做1亿亿次的话…… P1008 P1035 P1423 P1424 P1980 数组 跟数组有关的题目基本上都要用到循环，所以请先完成1-3。 P1046 P1047 P1427 P1428 P2141 P1567 简单字符串 计算机不仅可以处理数字，还能处理文字！就是其实跟数字也没什么差。 P1055 P1200 P1308 P1553 P1598 P1914 过程函数与递归 将代码串进行打包，就是过程与函数。过程与函数调用自己则为递归。有一点小难但不要怕哦。 P1028 P1036 P1149 P1217 BOSS战-入门综合练习1 这里将前面的内容综合起来了，会有点难，不过你可以问老师同学，也能上网查资料。 P1478 P1618 P1579 P2089 BOSS战-入门综合练习2 勇士，竟然来到了BOSS的老巢！来一场恶斗，证明自己的实力，解锁下一个级别！ P1426 P1464 P1014 P1022 P1307 普及练习场 普及组选手可冲刺训练，提高组选手亦可在此巩固基础。 简单的模拟 开始普及组的训练！所谓模拟，就是直接根据题意编写，思维难度简单。 P1003 P1067 P1540 P1056 P1328 P1563 交叉模拟 这里也是模拟，但是会混有些别的部分。思维难度不大，但是编写起来会有些难度。 P1023 P1031 P1042 P1086 P1098 P3952 排序 将杂乱无章的数据变得有规律。有各种各样的排序算法，看情况使用。 P1177 P1059 P1068 P1781 排序Ex 这里的排序就更上一层了。不仅融合了别的算法与技巧，排序本身也有各种花招。 P1583 P1051 P1093 P1309 字符串处理 这里的字符串处理还会变得更加的有意思，难度也更大。需要好好地思考一下。 P1603 P1071 P1012 P1538 贪心 贪心就是只考虑眼前的利益。对于我们人生来说太贪是不好的，不过oi中，有时是对的。 P1090 P1181 P1208 P1223 P1094 P1803 P1031 P1080 深度优先搜索 搜索可以穷举各种情况。很多题目都可以用搜索完成。就算不能，搜索也是骗分神器。 P1219 P1019 P1101 P1605 P1040 P1092 广度优先搜索 广度优先搜索可以用来找有关“最短步数”的问题。恩，也可以用来“地毯式搜索”。 P1162 P1032 P1141 P1126 P1443 带有技巧的搜索 这里的搜索不仅包含了dfs和bfs，还包括剪枝、记录等技巧以加快速度。 P1118 P1434 P1433 P1074 分治算法 将大问题拆分为小问题，分而治之，各个击破，然后在合并回来。 P1226 P1010 P1908 P1498 简单数学问题 用计算机解决某些麻烦数学问题，再合适不过了。这真是绝妙的搭配啊！ P1088 P1045 P1403 P1017 P1147 P1029 递推与递归二分 递推，层层递进，由基础推向顶层。二分不仅可以用来查找数据，还可以确定最合适的值。 P1192 P1025 P1057 P1135 P1216 P1182 P1316 线性数据结构 数组，链表，队列，栈，都是线性结构。巧用这些结构可以做出不少方便的事情。 P1996 P1115 P1739 P1160 P1449 树形数据结构 由一个根节点分叉，越分越多，就成了树。树可以表示数据之间的从属关系 P1087 P1030 P1305 P5018 动态规划的背包问题 这是最基础的动态规划。不过如果是第一次接触会有些难以理解。加油闯过这个坎。 P1060 P1164 P1064 P1048 P1049 P1616 线性动态规划 这也是基础的动态规划。是在线性结构上面的动态规划，一定要掌握。 P1020 P1091 P1280 P1880 P1140 P1282 多维动态规划 这里的动态规划就不止一维了。不仅要小心时间复杂度，也要注意空间复杂度。 P1508 P1006 P1387 P1417 P1855 P1736 更要技巧的动规与记忆化 这边的题目有各种搞法。当然有的题目也可以使用记忆化搜索来降低思维难度。 P1064 P1541 P1026 P1063 P1156 P1052 高精度算法 就算是long long（或int64）还不够怎么办？用高精度算法。自己动手丰衣足食。 P1601 P2142 P1303 P1255 P1604 贪心EX 虽然是贪心题，可能不是你当时你虐着玩的贪心惹qwq P1080 P1031 P1233 P2123 简单数学 数学和oi是密切相关的，数学不仅是oi的基础，而且是算法的核心。 P1865 P1372 P1338 P2158 P1582 BOSS战-普及综合练习1 好不容易闯到这一关，你那还等什么呢？抄起家伙赶快上啊！ P1478 P1203 P1363 P1736 BOSS战-普及综合练习2 来搞定第二个BOSS。虽然战斗艰难，但你一定没有问题。 P1201 P1095 P1058 P2258 P1108 BOSS战-普及综合练习3 普及练习场的大BOSS：“一定让你有去无回”。怎么办呢？只能打倒他开启下一个级别！ P1328 P1062 P1969 P1037 普及常见模板 这里集中了比较基础的算法的模板。提高和省选也有模板题哦！ P1177 P3366 P3367 P3371 P3383 提高历练地 已经去除了普及组难度的，请组织放心。成长大牛之必写题！！！ 搜索Ex 开始提高组的试炼。这里已经去除了所有普及组难度的题目。哼哼，怕了吧。。 P1120 P1378 P1514 P1312 P1441 P1242 动态规划TG.lv(1) 这是提高组难度中比较基础的动态规划，也许一两个转移方程就可以写出。 P1005 P1373 P2279 P1220 P1156 动态规划TG.lv(2) 这里的动态规划稍稍有所加大难度，思考转移方程的时间可能会与编写程序的时间持平。 P1273 P1169 P2577 P1070 P2051 动态规划TG.lv(3) 比较需要技巧的动态规划。有的不仅仅需要状态转移方程，可能还会与别的算法综合。 P1415 P2157 P2216 P2331 P2467 P3084 数论 数论就是研究整数的理论。包括公约公倍数、质数、欧拉定理和同余方程等。 P2152 P1414 P1134 P1313 P1306 博弈论 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 P1199 P1288 P1290 P2148 P1247 P2575 其他数学问题 听说学oi的同志们数学都挺好。那么。就请完成下面的题目证明这一点吧！ P1357 P1641 P2059 P2154 P2261 P2327 P1066 图的遍历 图是一种非常重要的数据结构，描述对象复杂的练习。这里开始接触图的基本概念。 P2661 P1330 P1341 P2921 最短路问题 最短路是图论中最重要的部分，多种算法可以应用。很多题目都可以抽象成这种模型。 P1339 P1462 P1346 P1119 P1144 P1522 最小生成树 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。 P1546 P2330 P1991 P1265 较复杂图论I 别的些图论问题，包括树、拓扑排序等。要过这一关，需要学习不少新的算法。 P1113 P1268 P1525 P1983 较复杂图论II 更高级的图论算法。包括差分约束、强连通、二分图等。会更难一些。 P1993 P1726 P2055 P2149 P1345 并查集 用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。 P1111 P2024 P1197 P1196 堆 堆总是一棵完全树；堆中某个节点的值总是不大于或不小于其父节点的值。 P1801 P2278 P1631 P2085 P1484 线段树树状数组基础 这都是比较高级的线性数据结构。在处理一些询问与修改线性问题时，是很好用的。 P1972 P1198 P2023 P2161 神奇的解法 有些问题刚开始觉得无从下手。好好想一想，尽量别看题解，否则你会大呼“简单”。 P1007 P1984 P2022 P2320 倍增 一种特殊的枚举算法，但可大大加快效率。近年noip有考到。难度较大。 P1967 P1081 P1613 强连通分量 强连通分量 P2341 P3469 P2746 P3119 P3225 BOSS战-提高综合练习1 年轻人，又是个送上门的，让我来看看你真实的本领。啊哈哈哈哈哈！ P2264 P1772 P1083 P1979 P2939 BOSS战-提高综合练习2 再来！这里有的题目并非单纯的考察某个算法，而是考察一种综合性的思维。 P1901 P1314 P2144 P1073 P2324 BOSS战-提高综合练习3 既然已经打倒了前面2个boss，那么第3个也是没有问题的。少年，来吧！ P1965 P1311 P2296 P1084 提高模板-nlogn数据结构 虽然这些算法不是noip必须的，但是不算困难，很多题目可以使用这些方法。 P3374 P3368 P3372 P3373 P1439 P3378 省选斗兽场/NOI神殿 为省选及以上选手制作的训练场。其实，省选水平的oier不需要一些外加的刷题列表，本栏仅供参考，也欢迎各位指出不足。 省选基础-读入/输出优化 读入/输出优化是省选刷题时必要的一个东西，这里给出了几题，需要自己手写相应的读入输出处理。作为第一关，这一关相对简单。 P1580 P2393 P2394 省选基础-位运算 位运算往往在必要的时候,能带你优化一下常数,也许是空间;也许是时间;有的时候这样可以多过很多分 P2114 P2396 P2397 省选基础-打表 打表虽然很赖皮,而且基本都是非正解,但是这种办法能让我们在省选中拿到一些会超时或者会超空间的一些数据点 P1149 P1463 P1896 动态规划1 动态规划 P2051 P1879 P1850 P2831 P1131 P1169 动态规划2 动态规划 P1273 P3648 P2519 P2515 P3233 P2501 网络流——最大流 最大流 P2765 P2764 P2763 P2766 P2774 P2805 网络流——费用流 费用流 P2153 P2053 P3159 P2604 P2050 P3980 单调队列 单调队列 P2698 P2216 P2219 P2564 P2569 概率期望 概率期望 P2473 P2221 P3317 P3343 P3600 P3830 二分图 二分图 P3386 P1640 P1129 P1963 P3231 P2526 点分治 点分治 P2634 P2664 P3806 P3676 后缀数组 后缀数组 P3809 P1117 P2178 P2463 P2336 主席树 主席树 P2468 P3157 P3302 P3168 P3313 数位DP 数位DP P2602 P3281 P2518 P2606 AC自动机 AC自动机 P3808 P3796 P2444 P2414 平衡树 平衡树 P2042 P2596 P1110 P3285 P3644 P3765 P3369 树链剖分 树链剖分 P2590 P2486 P2146 P3258 P3178 动态树 动态树 P3690 P2387 P3203 P3348 树套树 树套树 P1903 P3157 P3332 P2166 P3380 P2137 P3759 可持久化Trie树 可持久化Trie树 P2048 P3527 P3302 P3168 P3242 P3241 P3293 莫队算法 莫队算法 P1972 P2336 P3709 P2709 P3674 分块 分块 P1972 P3396 P1822 P2801 P3203 莫比乌斯反演 莫比乌斯反演 P3768 P3172 P3455 P2522 P3327 其他 其他 P3377 P3261 P3382 P2571 P3222 P3187 P3199 P3292 P2824 P3285 P1552 USACO 美国经典的算法练习题库，值得一刷 USACO Section 1.1 P1200 P1201 P1202 P1203 USACO Section 1.2 完全枚举 P3864 P1204 P1205 P1206 P1207 USACO Section 1.3 贪心 P1208 P1209 P1211 P1444 P3650 P2693 USACO Section 1.4 有技巧的枚举 P1214 P1215 USACO Section 1.5 二进制数 P1216 P1217 P1218 USACO Section 2.1 图论和洪水填充 P1457 P1458 P1459 P1460 P1461 USACO Section 2.2 数据结构与动态规划 P1465 P1466 P1467 P1468 USACO Section 2.3 P1470 P1472 P1473 P1474 P1475 USACO Section 2.4 最短路径 P1518 P1519 P1522 P1529 P1530 USACO Section 3.1 最小生成树 P1546 P2722 P2723 P2724 P2725 USACO Section 3.2 背包问题 P1134 P2727 P2728 P2729 P2730 P1828 USACO Section 3.3 欧拉回路 P2731 P2732 P1930 P2733 P2734 USACO Section 3.4 计算几何 P1827 P2735 P2736 USACO Section 4.1 最优化 P2737 P2738 USACO Section 4.2 网络流 P2740 P1894 P2751 USACO Section 4.3 高精度 P2687 P2752 P2753 USACO Section 4.4 P1344 P2739 P2741 USACO Section 5.1 二维凸包 P2742 P2743 P2749 USACO Section 5.2 P1560 USACO Section 5.3 启发式搜索 P2701 P2744 P2745 P2746 USACO Section 5.4 P1345 P2747 P2748 USACO Section 5.5 P1709 P1856 P2750 ","link":"https://OI-Master.github.io/post/luo-gu-shi-lian-chang/"},{"title":"Atcoder AGC 043 A 题解","content":"这道题把我坑的无话可说，实在是服了这个做法。动态规划！当时没想出来，现在想想，感觉自己理解得差不多了……好了，回归正题，我们先按照老配方——题面先。 题面 英文题面 请你走 这里 ，会带你去 Atcoder 官网。 中文题面 这道题大意是这样的： 给你一个 H×WH\\times WH×W 的迷宫，其中，“.”代表空地，“#”代表墙。现在，让你从左上角的 (1,1)(1, 1)(1,1) 走到右下角的 (H,W)(H, W)(H,W) ，只能走右边或下面。不过，这与往常的题目不一样，不是问你最少要走多少步，也不是有几种走法。其实，这个迷宫可能不同，现在给你一个条件，就是选择一个矩阵，把这个区域内的所有的空地转成墙，墙转成空地。问你最少要多少个操作才能保证能同行。 思路 这道题，我们先看枚举。枚举什么呢？枚举操作次数，然后在嵌套一个枚举在哪里操作？答案是完美的，不会错，但是你不用写了，一定会超时。 然后，我们考虑贪心。如何贪心？这仍然是个问题。好像贪心很难想全，情况较多。那么引用一位学长的话，叫做： 贪心不行就 DP 。 好的，为了验证这句话的正确性，我们就做一下 DP 吧。不过，这道题的 DP 状态转移方程有点难想，显然，状态较多，一不小心套个四重循环就会爆（其实不一定，不过估计评测机不是用现在的高级 CPU，而是像 CCF 统一评测老爷机来评测的，最好不要冒这个险），所以，这个 DP 又是一个难写的 DP 啊，不好想。 卡在这里显然不太合适，我们先看一下要你写的代码吧，从微观开始讲。先提前说一下，这个代码不是本人自己写的，而是一位大佬 hhhyyyfff 写的，在此先膜拜一下。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; char s[110][110]; int H, W, f[110][110]; int main() { scanf(&quot;%d%d&quot;, &amp;H, &amp;W); for (int i = 1; i &lt;= H; ++i) scanf(&quot;%s&quot;, s[i] + 1); f[1][1] = s[1][1] == '#'; for (int i = 2; i &lt;= W; ++i) f[1][i] = f[1][i - 1] + (s[1][i - 1] == '.' &amp;&amp; s[1][i] == '#'); for (int i = 2; i &lt;= H; ++i) f[i][1] = f[i - 1][1] + (s[i - 1][1] == '.' &amp;&amp; s[i][1] == '#'); for (int i = 2; i &lt;= H; ++i) for (int j = 2; j &lt;= W; ++j) f[i][j] = min(f[i - 1][j] + (s[i - 1][j] == '.' &amp;&amp; s[i][j] == '#'), f[i][j - 1] + (s[i][j - 1] == '.' &amp;&amp; s[i][j] == '#')); printf(&quot;%d\\n&quot;, f[H][W]); return 0; } 首先，读入没什么难的事情了，主要就是后面的 DP 。 第一行与第一列的初始化大家应该也能看得懂，知道这是什么意思。唯独后面的条件是什么意思还不知道。待会我会解释的，您们放心。 然后，就是主要的 DP 了，发现仍然很简单。当你不看后面那个 (s[i - 1][j] == '.' &amp;&amp; s[i][j] == '#') 时，你一定会尖叫： 这个 DP 太土了！比 传纸条 还简单呐！ 看来，主要的核心就在那一个表达式上面了。表达式的意思是，这个点要不要再翻一次，对不对？这是显而易见的。 首先，如果这个点不是墙，那么小表达式的值一定为 000 。 我们来看看，如果上一步是从上方走下来的，且上方是个墙，那么要不要翻？显然，上边翻的时候，把这一格的墙也同时翻掉了，所以，不用再翻。但是如果上面一格是空地呢？说明没有翻到这个墙，这个墙还要再翻一次。 左边的也是对称的。 嘿，让我们往宏观走走。这个 DP 十分巧妙，在记录最少的翻的次数时，顺便就把翻的标记也延续下来了。十分有意思，也很巧妙。 代码 还是刚刚的代码。 还是 stO hhhyyyfff Orz 。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; char s[110][110]; int H, W, f[110][110]; int main() { scanf(&quot;%d%d&quot;, &amp;H, &amp;W); for (int i = 1; i &lt;= H; ++i) scanf(&quot;%s&quot;, s[i] + 1); f[1][1] = s[1][1] == '#'; for (int i = 2; i &lt;= W; ++i) f[1][i] = f[1][i - 1] + (s[1][i - 1] == '.' &amp;&amp; s[1][i] == '#'); for (int i = 2; i &lt;= H; ++i) f[i][1] = f[i - 1][1] + (s[i - 1][1] == '.' &amp;&amp; s[i][1] == '#'); for (int i = 2; i &lt;= H; ++i) for (int j = 2; j &lt;= W; ++j) f[i][j] = min(f[i - 1][j] + (s[i - 1][j] == '.' &amp;&amp; s[i][j] == '#'), f[i][j - 1] + (s[i][j - 1] == '.' &amp;&amp; s[i][j] == '#')); printf(&quot;%d\\n&quot;, f[H][W]); return 0; } 本文到此结束。 ","link":"https://OI-Master.github.io/post/atcoder-agc-043-a-ti-jie/"},{"title":"Codeforces Contest 1299 A & 1300 C 题解","content":"照搬我洛谷博客的题解（滑稽 题目 如果不知道题面请点击题目链接：https://www.luogu.com.cn/problem/CF1299A ，这次挂的是洛谷的链接，有翻译。 这里不多做介绍，毕竟这道题翻译的还行。 思路 或运算 首先，这道题一定是一道关于二进制的题目，作者对二进制其实不太敏感，所以我们不如一起研究一下这个或逻辑运算。如果你很熟悉，我建议跳过这一段。 这个运算是一位一位“或”的。 这个运算很快，因为是计算机底层的操作。 规则： 0|0=0 0|1=1 1|0=1 1|1=1 发现了：只有在两个数都为0的时候才会是0，其他时候返回1。 那么再举个例子，5|3是多少？ 5转二进制是101 3转二进制是11 那么就是这样的画面： 101 011 //这里位数不够，补前导零 111 -&gt; 7 所以3|5的结果是7。 好的，现在关于或运算我们已经很熟悉了。 函数分析 接下来我们可以把这个函数f来研究研究。 这个函数请你自己分析一些二进制，我在这里只写一个结论。请你自觉分析。 好嘞，现在我来告诉大家自己分析的结果。 这个函数有两个参数，我们把它们命名为x和y。 我们一位一位看。（二进制） 如果y的这位是0的话，那么这一位最终结果就是x的这一位。 如果y的这位是1的话，那么这一位最终结果就是0。（为什么？大家自己想吧） 但是我们再看看这个函数有点乱，这道题目的函数嵌套实在是太烦了，不如我们把这个函数的内容弄在一个运算符里，把这个新符号叫做#。 这样，整个表达式就可以被整理了。最后发现结果就是 a1#a2#a3#...#an−1#ana_1\\#a_2\\#a_3\\#...\\#a_{n-1}\\#a_n a1​#a2​#a3​#...#an−1​#an​ 居然这么简单！现在这个运算符的操作我们也知道了，我们只需要想一想怎样可以让这个数字最大。 我们先要了解，这个运算符是有一下的性质的。 a1#a2#a3#...#an−1#an=a1#a3#a4#...#an#a2a_1\\#a_2\\#a_3\\#...\\#a_{n-1}\\#a_n=a_1\\#a_3\\#a_4\\#...\\#a_n\\#a_2 a1​#a2​#a3​#...#an−1​#an​=a1​#a3​#a4​#...#an​#a2​ 光这样写我知道你肯定弄不懂这是什么意思的，我用中文再表达一遍。 这个运算符号把第一个数确定后，不管后面的数字怎么调换位置，这个结果都是不变的。 为什么？你可以结合上面这个运算符的意义来证明。 这样，我们只需确定第一个数是多少了。 解法 有没有发现，题目已经变得很简单了？没错，我们现在只需要判断第一个数是什么。 我们可以假设这个数字已经确定了。 接下来，我们再次分析。注意，后面凡是提到数位的一定是二进制。 如果这个数字的某一位是111，且后面的一大堆数其中有至少一个数在这一位上也是111，我可以瞬间告诉你，这一个111已经报废了。为什么啊？因为这个运算符中，我们算到后来，一定会到这一位上也是111的那个数。当yyy这一位上的数字为111时，不管xxx这一位是几，结果都会是0。相当于这个数位已经无效了。 所以，我们发现有效位数只有有且整个数组只有1个数在这一位上是1的几位。 求这个很方便，预处理一下就行了。 接下来，我们可以把每个数字里的有效位都拿出来，组成数组bbb。 最后，只需要求出这个数组中最大的一个数，记下来下标maximaximaxi，然后输出就行了。 输出 我们只需要先答应amaxia_{maxi}amaxi​，最后顺序打印其他的数即可。 复杂度分析 首先，我们的方法几乎就是“比较大小”。 每个数扫一遍是O(N)O(N)O(N)算法。 中间内循环来取每个数的有效位最多有323232次，而且还多了。为什么？C++中的int型变量或者是Pascal的longint变量就是323232位的，最大值为214748364721474836472147483647，远远比数据范围中的aia_iai​大了222倍多。 显然，不会超时。 代码 C++代码： #include&lt;iostream&gt; using namespace std; int n; int bin[32]; int check(int x){ int j=0; int ret=0; while(x){ if((x&amp;1)&amp;&amp;bin[j]==1) ret+=(1&lt;&lt;j); x&gt;&gt;=1; ++j; } return ret; } int main(){ cin&gt;&gt;n; int a[n+1]; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;a[i]; int p=a[i]; int j=0; while(p){ if(p&amp;1) ++bin[j]; p&gt;&gt;=1; ++j; } } int maxi,maxv=-1; for(int i=1;i&lt;=n;++i){ int j=check(a[i]); if(j&gt;maxv){ maxv=j; maxi=i; } } cout&lt;&lt;a[maxi]&lt;&lt;' '; for(int i=1;i&lt;=n;++i) if(i!=maxi) cout&lt;&lt;a[i]&lt;&lt;' '; return 0; } 不过，还是希望大家自己完成代码，增加印象。 ","link":"https://OI-Master.github.io/post/codeforces-contest-1299-a-and-1300-c-ti-jie/"},{"title":"Codeforces Contest 1322 D1 题解 ","content":"本人太菜，不会 D2 的优化，大佬们自己写吧，欢迎在评论区填坑。 题面 英文题面 你可以在 这里 找到这道题的英文题面。 中文题面 题面大意是，给你一个串 SSS ，然后你需要找到一个字符串 TTT ，有以下约束： 字符串 TTT 的长度不大于 SSS 的长度； 字符串 TTT 是一个回文串； 我们再定义两个串 AAA 和 BBB ，一个是 SSS 的一个前缀，一个是 SSS 的一个后缀，当然，可能是空串，要你自己选，使得 T=A+BT = A + BT=A+B 。这里的 +++ 的意思是，字符串拼接。 你需要打印最长的 TTT ，且要回答 ttt 组数据。 不过输入输出格式我就不翻译了。 思路 这道题看看数据范围，发现 SSS 长度总和才为 500050005000 ，感觉这是一道偏暴力的题目。 然后本蒟蒻就想到一个暴力的算法：枚举开头选几个，同时枚举最后选几个，然后取出这个枚举出来的字符串，判断它是否回文。枚举开头时有 N+1N+1N+1 种可能，结尾也有 N+1N+1N+1 种，然后判断回文也要检查 ⌊N÷2⌋\\lfloor N \\div 2 \\rfloor⌊N÷2⌋ 个字符，所以这个算法是 O(N3)O(N^3)O(N3) 的，过不了，得想想更好的算法。 但是想这个算法，而没有目标，是不方便的。我们知道，目标算法至少得达到 O(N2)O(N^2)O(N2) ，否则一定超时。我们可以这么想：枚举前缀，在枚举后缀，两个是同时的，写两重循环显然不妥。我们可以想办法写一重循环。也许你会问，这样怎可以？你问的原因是，这个“前”与“后”是同时存在的，如果我们只让它们一个存在，那么是不是我们就可以把三重循环改成两个两重循环了？是的，当然可以。但是让一个存在不是题目的意思，我们还得把这个字符串加工加工。我们把开头、结尾已经成功配对的字符删除，当然，不是真的删除，要不你怎么打印？删除所有的配对字符后，开头与结尾只可能有一个还要继续选，那么你处理一下，选一选判断一下是否回文即可，纯属练坐标控制，没什么难度。 代码 工作量有点多，我给个参考代码，请自律不要复制。 /* * Author: OI_Master * Time: 2020-03-20 10:26:42 */ #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long bool huiwen(string s){ for(int i=0;i&lt;s.size()/2;++i) if(s[i]!=s[s.size()-1-i]) return false; return true; } signed main(){ ios::sync_with_stdio(false); cin.tie(0); int t; cin&gt;&gt;t; while(t--){ string s; cin&gt;&gt;s; int k=0; while(k&lt;s.size()/2&amp;&amp;s[k]==s[s.size()-1-k]) ++k; int i=k; while(i&lt;s.size()-1-k&amp;&amp;!huiwen(s.substr(i,s.size()-k-i))) ++i; int j=s.size()-1-k; while(j&gt;=k&amp;&amp;!huiwen(s.substr(k,j+1-k))) --j; cout&lt;&lt;s.substr(0,k); if(s.size()-k-i&lt;=j+1-k) cout&lt;&lt;s.substr(k,j+1-k); else cout&lt;&lt;s.substr(i,s.size()-k-i); cout&lt;&lt;s.substr(s.size()-1-k+1)&lt;&lt;endl; } return 0; } 本文到此结束，谢谢您的观看。 ","link":"https://OI-Master.github.io/post/codeforces-contest-1322-d1-ti-jie/"},{"title":"Codeforces Contest 1322 A & 1323 C 题解","content":"这道题调了好久，一 AC 马上就跑过来写了个题解。 题面 英文题面 这一道题目的英文题面可以在 这里 获取到，还可以在 这里 获取。 中文题面 大意就是，给你一个长度为 N(1≤n≤106)N (1 \\le n \\le 10^6)N(1≤n≤106) 的字符串 SSS ，这个字符串是一个只有圆括号（(、)）的字符串。不过这个字符串可能是一个不合法的字符串，所以我们要调整一下这个字符串，让它变得合法。调整的方法是选择一个子串 Si,Si+1,Si+2,…,Sj−1,SjS_i,S_{i+1},S_{i+2}, \\dots ,S_{j-1},S_jSi​,Si+1​,Si+2​,…,Sj−1​,Sj​ ，重新排列成任意你想要的格局，不过这个操作是要花费时间的，花费 j−i+1j-i+1j−i+1 的时间。现在问你，想让这个字符串合法，最少要花多长时间。 思路 这道题的算法时间复杂度是 O(N)O(N)O(N) ，我们可以在过程中每次处理一个“左括号的数量减去右括号的数量”的这个差，我们假设我们就来看看这个序列：()()((()()) ，把这些差处理一下，变成一张图，就会是这样子的。 但是，我们发现，红色部分（也就是差为负数的一段）中，括号是无法进行匹配的。所以，我们可以在这些括号内进行交换，变成这样子。 这样子，其实交换的部分就是“负数”的一块儿。 显然代码很容易写吧。 ","link":"https://OI-Master.github.io/post/codeforces-contest-1322-a-and-1323-c-ti-jie/"},{"title":"Notepad++","content":"Notepad++ 是 Windows 操作系统下的文本编辑器，支持多国语言、多种编码、多种编程语言的高亮和补全。它的 logo 也十分可爱，是一只变色龙。 不得不说这只小变色龙十分滑稽，不过我们先不谈了。我们现在谈的是这个软件的功能。这些功能比其他的编辑软件强大许多，例如打开一个超大文件更稳定，不容易崩溃，不停地撤销的时候也不会出什么问题。而且，就算是你忘记保存也没关系。这个程序会自动把所有文件的暂时修改本存在缓冲区，不过在一些版本中可能要进行配置。这个东西也很小巧，只有 10MB+ ，我们甚至可以把它装在闪存（也就是 U盘 ）里随身携带。 如何下载 我们可以打开 软件官网 ，如果你上不去也可以上 可靠的第三方网站 ，然后去 Download 页面 选择版本下载，推荐下载最新版，不过本次演示用的是 7.7.1 版本的，但是应该页面没什么改动。如果你的电脑是 64 位 的，强烈建议下载 64 位，因为这个软件的许多插件只能支持 64 位 。不过如果你渴望兼容性，也可以下载 32 位。如果你的网络实在上不了外国网站，也可以尝试各种软件园，不过有一定的风险。不过，我在我的微云上也传上了一个 Windows 系统的安装包，你可以在 这里 下载，密码就是 123456。 你会发现，有 333 种下载方法： installer——安装包模式，当你没有任何其他想法时的推荐模式。 zip/7z package——压缩包模式，当你不想用安装包时可以直接下载 -&gt; 解压 -&gt; 使用。 minimalist package——迷你模式，没有主题、插件和升级包，下载、安装更快捷。 我们这里用最推荐的安装包模式做范例。 请双击这个安装包，选择语言，接受协议，选择安装位置，然后安装内容： 因为窗口大小有限，所以后期 P 上了一个没进来的选项，大家不要在意这些细节。 我们先介绍一下这些东西的中文名，按照顺序。 自动编译功能（是吗？使用时没有这个感觉） 自带插件功能 自动升级插件 自定义插件功能 安装多国语言 软件主题商店 添加到右键菜单 然后会出来这么一个页面： 这里第一个勾勾是“是否创建桌面快捷方式”，第二个是“不要用 %APPDATA% ，也就是说，当你想在 闪存 里装的时候一定要勾上。 最后点击“安装”按钮即可。 更改界面语言 打开以后，应该会是一个英文界面。这时，我们需要更改语言。不过这个我们需要动图来帮忙，这里不好描述。 改完后，就可以魔改我们的编辑器啦！ 初级玩法 查找与替换 依次单击“（菜单栏）搜索”-&gt;“查找”（快捷键 CTRL + F ）即可打开“查找”页面（如下图） 依次单击“（菜单栏）搜索”-&gt;“替换”（快捷键 CTRL + H ）即可打开“替换”页面（如下图） 其实查找、替换之间其实是一个窗口，单击上面的标签页就可以完成切换。 其功能与普通编辑器大同小异，但是支持更多，如： 严格匹配或大小写匹配等 跨文档匹配 转义字符，如'\\r'，'\\n'。 正则表达式 计数 定期备份 有了这个功能，就可以不用费心地担心意外情况代码丢失啦！ 但是，这个功能只是为你的文件拍了一个快照，并没有真正保存，所以还是建议要有良好的保存习惯。或者说可以去自带插件商店安装 &quot;Auto Save&quot; 插件（详见 高级玩法-&gt;插件 ，下同）。 书签功能 在你需要的行按 Ctrl + F2 即可设放置或取消书签，放置过书签的行前段有一个蓝色圆点。 按 F2 可以定位到下一个书签。 如果你抱怨不方便，可以去自带插件商店安装“Bookmarks”插件 代码高亮 右击左下角的 &quot;XXX file&quot;，可以选择许多种语言高亮，C、C++、PASCAL、Markdown 等任你挑选。你甚至可以自己定义高亮！ 如果你认为每一次打开文件都要更改高亮很麻烦，可以在“设置 -&gt; 首选项 -&gt; 新建 -&gt; 默认语言”中修改默认高亮。 需要渲染 Markdown 的，可以去插件商店安装 &quot;Markdown Viewer&quot;，还有更多类似插件等着你！ 显示所有字符 点击红框所圈的按钮，就可以非（za）常（luan）清（wu）晰（zhang）地显示出“空格”、“TAB”、“换行”等原来不可见字符。 自动识别文件编码与换行符 Notepad++ 可以自动识别当前文件编码是 UTF-8 还是 GB2312 甚至其他。 如果要使用不同的编码浏览文章，请依次单击“（菜单顶栏）编码”-&gt;“使用 XXX 编码”。如果想给文件换一个字符编码，请依次单击“（菜单顶栏）编码”-&gt;“转为 XXX 编码”。 它还可以自动识别换行符是 CR 、 LF 或 CRLF 。不用担心下载下来的数据被吞换行。 在底部信息栏，你可以看到 &quot;Windows(CR LF)&quot; 等字样，这就是当前文件的换行符。右击它，可以改变当前文件换行符。此操作配合“显示所有字符”更直观哟！ 高级玩法 这个就适用于需求较高的用户。 宏 宏可以帮助你完成许多重复的工作，例如，我要将奇数行的“abcde”改为“afce ”，需要两步。 录制宏 使用宏 大量处理，重复使用 如果是更多行呢？操作就需要一点改变。 首先是录制，一定要先按键盘上的 HOME 或 END 键将光标移动到行首或行尾，然后用方向键调整横向位置，再进行更改。最后一定要用方向键将光标移动到下一个要处理的行。 比如刚刚的例子，可以先按 END 键，然后依次按 ← ， Backspace , ← , Backspace , F ，最后按两下 ↓ ，最后停止录制。 然后是重播，先定位到第一个要处理的行（第 3 行），然后点击“宏”-&gt;“重复运行宏”。在弹出窗口设置要运行的宏（刚录制的一般是第一个），设置运行次数（或者直接运行到文件尾），点确定即可。 保存宏 点击“宏”-&gt;“保存录制宏”，并设置名称和快捷键，即可保存，方便后续使用。 插件 插件管理 打开功能栏的“插件”按钮，列表中会显示所有你安装过的插件。 再选择“插件管理”选项，即可管理你的插件。 安装插件（商店） 打开“可用”选项卡，在列表中勾选你所要的插件 点击右上角的“安装”按钮，按照提示重启软件即可。 安装插件（手动） 下载插件（由第三方托管的官方地址： https://sourceforge.net/projects/npp-plugins/ ）注意一定要选择 与安装 Notepad++ 时处理器架构相同 的插件。 找到一个名为 &quot;XXX.dll&quot; 的文件（通常以插件名命名）。 在 Notepad++ 中的功能栏点插件，并在列表中点“打开插件文件夹”。 将刚才找到的 DLL 文件放入文件夹中，重启 Notepad++。 【可选】删除刚才拷贝的文件， 但不要删除生成的文件夹！ Tips: 如果多次不成功，可以尝试新建一个与插件名相同的文件夹在将 &quot;.dll&quot; 文件放入创建的文件夹中 更新插件 在插件管理中，选择“更新”选项卡，并勾选要更新的插件，然后点右上角的“更新”按钮。 移除插件 同样在插件管理中，选择“已安装”选项卡，并勾选要移除的插件，然后点右上角的“移除”按钮。 搭建开发环境 不只是编辑器！&quot;Notepad++&quot; 可谓神一样的存在，它可以通过傻瓜式地编译代码，甚至代替 IDE！这里以 C++ 为例 安装编译器并将其必要的文件目录添加到 PATH 环境变量中。（C++ 需要添加 %APPPATH%\\bin）当你在 cmd 中输入 g++ 时不再提示'g++'不是内部或外部命令……即可（中间可能需要重启电脑）。推荐 下载 ConsolePauser 然后随便放并将其目录添加到环境变量（此为 Dev-C++ 的插件，在 Dev-C++ 软件根目录也有）。 在菜单栏中选择“运行”-&gt;“运行……”，打开“运行”窗口。 分别输入以下命令 #编译命令： cmd /c g++.exe -o $(CURRENT_DIRECTORY)\\$(NAME_PART).exe $(FULL_CURRENT_PATH) #运行命令： cmd /c $(CURRENT_DIRECTORY)\\$(NAME_PART).exe $(FULL_CURRENT_PATH) &amp; pause #调试命令： cmd /c gdb $(CURRENT_DIRECTORY)\\$(NAME_PART).exe #如果下载了ConsolePauser可以使用下列代码获得更好的程序运行体验！（注意添加环境变量！） #编译命令： cmd /c (start ConsolePauser &quot;g++.exe -o $(CURRENT_DIRECTORY)\\$(NAME_PART).exe $(FULL_CURRENT_PATH)&quot;) #运行命令： cmd /c (start ConsolePauser &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot;) #调试命令： cmd /c (start ConsolePauser &quot;gdb $(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot;) 单击“保存”，名字可以自己取，如 &quot;Compile&quot;,&quot;Run&quot; 等，然后设定好你想要的快捷键（捡好记的来，如 Dev-C++ 就分别是 F9 和 F10 ）。 尽情享受吧！ 彩蛋 在运行安装程序时你会在下方看到这样一句话： &quot;The best things in life are free. Notepad++ is free. So Notepad++ is the best(.)&quot; （生活中最好的事情都是免费的。Notepad++ 是免费的。所以 Notepad++ 是最好的。） 在一个新开的页面中输入 &quot;random&quot; 并选中，再按 F1 就会得到一句很有意思的话。 ","link":"https://OI-Master.github.io/post/notepad/"},{"title":" USACO 2020 February Contest, Bronze 题解","content":"这次比赛的铜组其实很简单的，很快就可以 AK 掉了。大佬勿喷！ 废话不多说，我们先看第一题吧。 Problem 1. Triangles 题面 Farmer John would like to create a triangular pasture for his cows. There are NNN fence posts (3≤N≤100)(3 \\leq N \\leq 100)(3≤N≤100) at distinct points (X1,Y1)...(XN,YN)(X_1,Y_1) ... (X_N,Y_N)(X1​,Y1​)...(XN​,YN​) on the 2D map of his farm. He can choose three of them to form the vertices of the triangular pasture as long as one of the sides of the triangle is parallel to the xxx-axis and another side is parallel to the yyy-axis . What is the maximum area of a pasture that Farmer John can form? It is guaranteed that at least one valid triangular pasture exists. INPUT FORMAT (file triangles.in): The first line of the input contains the integer NNN . Each of the next NNN lines contains two integers XiX_iXi​ and YiY_iYi​, each in the range −104…104−10^4…10^4−104…104 inclusive, describing the location of a fence post. OUTPUT FORMAT (file triangles.out): As the area itself is not necessarily an integer, output two times the maximum area of a valid triangle formed by the fence posts. SAMPLE INPUT: 4 0 0 0 1 1 0 1 2 SAMPLE OUTPUT: 2 Posts at (0,0)(0,0)(0,0) , (1,0)(1,0)(1,0) , and (1,2)(1,2)(1,2) form a triangle of area 111. Thus, the answer is 2×1=22 \\times 1=22×1=2. There is only one other triangle, with area 0.50.50.5 . Problem credits: Travis Hance 农民约翰想为他的奶牛建造一个三角形的牧场。 在不同的点 (X1,Y1)(X_1,Y_1)(X1​,Y1​) 上有 NNN 个围栏立柱 (3≤N≤100)(3 \\leq N \\leq 100)(3≤N≤100)。 (Xn,Yn)(X_n,Y_n)(Xn​,Yn​) 在他农场的 2D 地图上。 只要三角形的一条边平行于 xxx 轴，另一条边平行于 yyy 轴，他就可以选择其中的三条边来形成三角形牧场的顶点。 农民约翰能形成的最大牧场面积是多少？ 保证至少存在一个有效的三角牧场。 输入格式(文件名：triangles.in)： 输入的第一行包含整数 NNN 。接下来的 NNN 行中的每一行都包含两个整数XiX_iXi​和 YiY_iYi​，每一个数都在−104…104−10^4…10^4−104…104的范围内，描述围栏柱的位置。 输出格式(文件名：triangles.out)： 由于面积本身不一定是整数，因此输出由栅栏柱形成的有效三角形的最大面积的两倍。 示例输入： 4 0 0 0 1 1 0 1 2 示例输出： 2 (0,0)(0,0)(0,0)、(1,0)(1,0)(1,0)和(1,2)(1,2)(1,2)处的柱子形成一个面积为 111 的三角形。因此，答案是2×1=22 \\times 1=22×1=2。其他的三角形只有一个，面积为 0.50.50.5 。 问题提供：特拉维斯·汉斯 思路 这道题目其实不难。我们知道确定一个三角形需要确定三个点的位置，那么我们在这道题目中也可以这么干，用三重循环来确定。循环中加上几个 if 语句来确定“三角形的一条边平行于 xxx 轴，另一条边平行于 yyy 轴”，就可以了。时间复杂度为 O(N3)O(N^3)O(N3)，这里的 NNN 最大才 100100100 ，不会超时。 代码 #include&lt;fstream&gt; using namespace std; inline int abs(int x){ return max(x,-x); } ifstream cin(&quot;triangles.in&quot;); ofstream cout(&quot;triangles.out&quot;); int main(){ int n; cin&gt;&gt;n; int maxv=0; int a[n],b[n]; for(int i=0;i&lt;n;++i) cin&gt;&gt;a[i]&gt;&gt;b[i]; for(int i=0;i&lt;n-2;++i) for(int j=i+1;j&lt;n-1;++j) for(int k=j+1;k&lt;n;++k){ if(a[i]==a[j]){ if(b[i]==b[k]) maxv=max(maxv,abs(b[i]-b[j])*abs(a[i]-a[k])); if(b[j]==b[k]) maxv=max(maxv,abs(b[i]-b[j])*abs(a[j]-a[k])); } if(a[i]==a[k]){ if(b[i]==b[j]) maxv=max(maxv,abs(b[i]-b[k])*abs(a[i]-a[j])); if(b[j]==b[k]) maxv=max(maxv,abs(b[i]-b[k])*abs(a[j]-a[k])); } if(a[j]==a[k]){ if(b[i]==b[j]) maxv=max(maxv,abs(b[j]-b[k])*abs(a[i]-a[j])); if(b[i]==b[k]) maxv=max(maxv,abs(b[j]-b[k])*abs(a[i]-a[k])); } } cout&lt;&lt;maxv&lt;&lt;endl; return 0; } Problem 2. Mad Scientist 题面 Farmer John's cousin Ben happens to be a mad scientist. Normally, this creates a good bit of friction at family gatherings, but it can occasionally be helpful, especially when Farmer John finds himself facing unique and unusual problems with his cows. Farmer John is currently facing a unique and unusual problem with his cows. He recently ordered NNN cows (1≤N≤1000)(1 \\leq N \\leq 1000)(1≤N≤1000) consisting of two different breeds: Holsteins and Guernseys. He specified the cows in his order in terms of a string of NNN characters, each either HHH (for Holstein) or GGG (for Guernsey). Unfortunately, when the cows arrived at his farm and he lined them up, their breeds formed a different string from this original string. Let us call these two strings AAA and BBB, where AAA is the string of breed identifiers Farmer John originally wanted, and BBB is the string he sees when his cows arrive. Rather than simply check if re-arranging the cows in BBB is sufficient to obtain AAA, Farmer John asks his cousin Ben to help him solve the problem with his scientific ingenuity. After several months of work, Ben creates a remarkable machine, the multi-cow-breed-flipinator 3000, that is capable of taking any substring of cows and toggling their breeds: all Hs become Gs and all Gs become Hs in the substring. Farmer John wants to figure out the minimum number of times he needs to apply this machine to transform his current ordering BBB into his original desired ordering AAA. Sadly, Ben's mad scientist skills don't extend beyond creating ingenious devices, so you need to help Farmer John solve this computational conundrum. INPUT FORMAT (file breedflip.in): The first line of input contains NNN , and the next two lines contain the strings AAA and BBB . Each string has NNN characters that are either H or G. OUTPUT FORMAT (file breedflip.out): Print the minimum number of times the machine needs to be applied to transform BBB into AAA . SAMPLE INPUT: 7 GHHHGHH HHGGGHH SAMPLE OUTPUT: 2 First, FJ can transform the substring that corresponds to the first character alone, transforming BBB into GHGGGHH. Next, he can transform the substring consisting of the third and fourth characters, giving AAA. Of course, there are other combinations of two applications of the machine that also work. Problem credits: Brian Dean Farmer John 的远房亲戚 Ben 是一个疯狂的科学家。通常这会在家庭聚会时造成不小的摩擦，但这偶尔也会带来些好处，尤其是当 Farmer John 发现他正面对一些有关他的奶牛们的独特而不寻常的问题时。 Farmer John 当前正面对一个有关她的奶牛们的独特而不寻常的问题。他最近订购了 NNN 头奶牛（1≤N≤10001 \\leq N \\leq 10001≤N≤1000），包含两种不同品种：荷斯坦牛和更赛牛。他在订单中用一个长为 NNN 的字符串来指定奶牛，其中的字符为 H（表示荷斯坦牛）或 G（表示更赛牛）。不幸的是，当这些奶牛到达他的农场，他给她们排队时，她们的品种组成的字符串与原先的不同。 我们将这两个字符串称为 AAA 和 BBB，其中 AAA 是 Farmer John 原先想要的品种字符组成的字符串，BBB 是他的奶牛们到达时组成的字符串。Farmer John 并没有简单地检查重新排列 BBB 中的奶牛是否能得到 AAA，而是请他的远房亲戚 Ben 利用他的科学才华来解决这一问题。 经过数月的研究，Ben 发明了一台不同寻常的机器：奶牛品种转换机3000，能够选择任意奶牛组成的子串并反转她们的品种：在这个子串中的所有 H 变为 G，所有 G 变为 H。Farmer John 想要求出将他当前的序列 BBB 变为他本来订购时想要的 AAA 需要使用这台机器的最小次数。然而，Ben 的疯狂的科学家技能并不会处理开发奇异机器以外的事，所以你需要帮助 Farmer John 解决这个计算难题。 输入格式（文件名：breedflip.in）： 输入的第一行包含 NNN，以下两行包含字符串 AAA 和 BBB。每个字符串均包含 NNN 个字符，字符均为 H 和 G 之一。 输出格式（文件名：breedflip.out）： 输出将 BBB 变为 AAA 需要使用机器的最小次数。 输入样例： 7 GHHHGHH HHGGGHH 输出样例： 2 首先，FJ 可以仅改变第一个字符组成的子串，将 BBB 变为 GHGGGHH。然后，他可以改变由第三和第四个字符组成的子串，得到 AAA。当然，还存在其他有效的执行两次操作的方案。 题目提供：Brian Dean 思路 这道题也不难。我们知道，我们要尽可能地把牛转到正确的品种，只需要把那些错误的牛拎出来 啥？我拎不动 ，然后求出它们分为多少块连续的，就可以输出了。这道题时间复杂度为 O(N)O(N)O(N) ，很快。 代码 #include&lt;fstream&gt; using namespace std; ifstream cin(&quot;breedflip.in&quot;); ofstream cout(&quot;breedflip.out&quot;); int main(){ int n; cin&gt;&gt;n; string a,b; cin&gt;&gt;a&gt;&gt;b; int tot=0; if(a[0]!=b[0]) ++tot; for(int i=1;i&lt;n;++i) if(a[i]!=b[i]&amp;&amp;a[i-1]==b[i-1]) ++tot; cout&lt;&lt;tot&lt;&lt;endl; return 0; } Problem 3. Swapity Swap 题面 Farmer John's NNN cows (1≤N≤1001\\le N\\le 1001≤N≤100) are standing in a line. The iiith cow from the left has label iii, for each 1≤i≤N1\\le i\\le N1≤i≤N. Farmer John has come up with a new morning exercise routine for the cows. He tells them to repeat the following two-step process exactly KKK (1≤K≤1091\\le K\\le 10^91≤K≤109) times: The sequence of cows currently in positions A1…A2A_1 \\ldots A_2A1​…A2​ from the left reverse their order (1≤A1&lt;A2≤N1\\le A_1&lt;A_2\\le N1≤A1​&lt;A2​≤N). Then, the sequence of cows currently in positions B1…B2B_1 \\ldots B_2B1​…B2​ from the left reverse their order (1≤B1&lt;B2≤N1\\le B_1&lt;B_2\\le N1≤B1​&lt;B2​≤N). After the cows have repeated this process exactly KKK times, please output the label of the iiith cow from the left for each 1≤i≤N1\\le i\\le N1≤i≤N. SCORING: Test cases 2-3 satisfy K≤100K\\le 100K≤100. Test cases 4-13 satisfy no additional constraints. INPUT FORMAT (file swap.in): The first line of input contains NNN and KKK. The second line contains A1A_1A1​ and A2A_2A2​, and the third contains B1B_1B1​ and B2B_2B2​. OUTPUT FORMAT (file swap.out): On the iiith line of output, print the label of the iiith cow from the left at the end of the exercise routine. SAMPLE INPUT: 7 2 2 5 3 7 SAMPLE OUTPUT: 1 2 4 3 5 7 6 Initially, the order of the cows is [1,2,3,4,5,6,7][1,2,3,4,5,6,7][1,2,3,4,5,6,7] from left to right. After the first step of the process, the order is [1,5,4,3,2,6,7].[1,5,4,3,2,6,7].[1,5,4,3,2,6,7]. After the second step of the process, the order is [1,5,7,6,2,3,4][1,5,7,6,2,3,4][1,5,7,6,2,3,4]. Repeating both steps a second time yields the output of the sample. Problem credits: Brian Dean Farmer John 的 NNN 头奶牛（1≤N≤1001\\le N\\le 1001≤N≤100）站成一排。对于每一个 1≤i≤N1\\le i\\le N1≤i≤N，从左往右数第 iii 头奶牛的编号为 iii。 Farmer John 想到了一个新的奶牛晨练方案。他让她们重复以下包含两个步骤的过程 KKK（1≤K≤1091\\le K\\le 10^91≤K≤109）次： 当前从左往右数在位置 A1…A2A_1 \\ldots A_2A1​…A2​ 的奶牛序列反转她们的顺序（1≤A1&lt;A2≤N1\\le A_1&lt;A_2\\le N1≤A1​&lt;A2​≤N）。 然后，在当前从左往右数在位置 B1…B2B_1 \\ldots B_2B1​…B2​ 的奶牛序列反转她们的顺序（1≤B1&lt;B2≤N1\\le B_1&lt;B_2\\le N1≤B1​&lt;B2​≤N）。 当奶牛们重复这一过程 KKK 次后，请对每一个 1≤i≤N1\\le i\\le N1≤i≤N 输出从左往右数第 iii 头奶牛的编号。 测试点性质： 测试点 2-3 满足 K≤100K\\le 100K≤100。 测试点 4-13 没有额外限制。 输入格式（文件名：swap.in）： 输入的第一行包含 NNN 和 KKK。第二行包含 A1A_1A1​ 和 A2A_2A2​，第三行包含 B1B_1B1​ 和 B2B_2B2​。 输出格式（文件名：swap.out）： 在第 iii 行输出晨练结束时从左往右数第 iii 头奶牛的编号。 输入样例： 7 2 2 5 3 7 输出样例： 1 2 4 3 5 7 6 初始时，奶牛们的顺序从左往右为 [1,2,3,4,5,6,7][1,2,3,4,5,6,7][1,2,3,4,5,6,7]。在这一过程的第一步过后，顺序变为 [1,5,4,3,2,6,7][1,5,4,3,2,6,7][1,5,4,3,2,6,7]。在这一过程的第二步过后，顺序变为 [1,5,7,6,2,3,4][1,5,7,6,2,3,4][1,5,7,6,2,3,4]。再重复这两个步骤各一次可以得到样例的输出。 供题：Brian Dean 思路 这道题本人刚开始认为是一个模拟题，但是写完后提交，TLE 了。有什么优化的方法呢？本蒟蒻在纸上写了很多组数据，发现了每组数据都有周期。这下好了，我们不用把所有的状态都枚举出来了，我们只需要枚举几次，剩下的就可以用公式来找了。至于怎么“记忆”，我推荐用 映射（map）。 代码 #include&lt;fstream&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;vector&gt; using namespace std; ifstream cin(&quot;swap.in&quot;); ofstream cout(&quot;swap.out&quot;); int main(){ int n,k; cin&gt;&gt;n&gt;&gt;k; int a[2],b[2]; cin&gt;&gt;a[0]&gt;&gt;a[1]&gt;&gt;b[0]&gt;&gt;b[1]; vector&lt;int&gt;id; id.resize(n+1); for(int i=1;i&lt;=n;++i) id[i]=i; map&lt;vector&lt;int&gt;,int&gt;m; int i; for(i=1;i&lt;=k;++i){ reverse(id.begin()+a[0],id.begin()+a[1]+1); reverse(id.begin()+b[0],id.begin()+b[1]+1); if(m.count(id)) break; m[id]=i; } if(i==k){ for(int i=1;i&lt;=n;++i) cout&lt;&lt;id[i]&lt;&lt;endl; return 0; } int rep=i-m[id]; int last=k-i; last%=rep; for(i=1;i&lt;=last;++i){ reverse(id.begin()+a[0],id.begin()+a[1]+1); reverse(id.begin()+b[0],id.begin()+b[1]+1); } for(int i=1;i&lt;=n;++i) cout&lt;&lt;id[i]&lt;&lt;endl; return 0; } 好了，本文到此结束。 ","link":"https://OI-Master.github.io/post/usaco-2020-february-contest-bronze-ti-jie/"},{"title":"用 C 语言实现数独","content":"如何用 C 语言实现数独呢？本文将会详细为你讲解。 规则 方格 水平方向有九横行，垂直方向有九纵列的矩形，画分八十一个小正方形，称为九宫格（Grid），如图一所示，是数独（Sudoku）的作用范围。 行 水平方向的每一横行有九格，每一横行称为行（Row），如图二所示。 列 垂直方向的每一纵列有九格，每一纵列称为列（Column），如图三所示。 宫 三行与三列相交之处有九格，每一单元称为小九宫（Box、Block），简称宫，如图四所示）。 组成 上述行、列、宫、单元格统称为单元（Unit）；而行、列、宫统称为区域（Region）。 区块 由三个连续宫组成大行列（Chute），分大行（Floor）及大列（Tower）。 第一大行：由第一宫、第二宫、第三宫组成。 第二大行：由第四宫、第五宫、第六宫组成。 第三大行：由第七宫、第八宫、第九宫组成。 第一大列：由第一宫、第四宫、第七宫组成。 第二大列：由第二宫、第五宫、第八宫组成。 第三大列：由第三宫、第六宫、第九宫组成。 格位编号 格位按所处的行列单元赋予坐标值，如图五所示。 坐标有多种标示法，有横行 A−IA-IA−I ，纵列 1−91-91−9 （如中国），也有横行 1−91-91−9 ，纵列 A−IA-IA−I （如日本），这两种标示容易混淆，故最被广泛使用的是横行 R1−R9R1-R9R1−R9 ，纵列 C1−C9C1-C9C1−C9 的标示法。 提示数 在九宫格的格位填上一些数字，做为填数判断的线索（Hint），称为提示数（Clue），如图六所示。 要求 我们需要干的就是使每行、每列与每宫的数字均为 1−91-91−9 ，且不重复。 如何解题 人类解数独的方法并不适合计算机，因为人类的逻辑不好让计算机模拟，就像我们现在还无法制作真正意义上的“人工智能”。但是计算机的运算速度极快，且毫无情感也不偷懒，所以现在这道难题就可以当作一道简单的枚举题。 枚举是很容易的，你只需要想办法记住所有的空坐标，然后挨个枚举，当完全填完后，就可以输出数独了。我们可以用 深度优先搜索（dfs） 来完成这个工作，但是唯一的困难就是检验。 我们可以先看列，把列全扫一遍，然后再扫行，确定在列与行中没有重复后，再看宫，宫的起始坐标不难求，实在不行可以打表 有点夸张 ，在源代码中会介绍。 源代码 #include&lt;stdio.h&gt; #include&lt;stdbool.h&gt; int s[10][10]; int x[82]; int y[82]; int n; int cnt; inline bool check(int x,int y){ int i; int j; const int xhead=(x-1)/3*3+1; const int yhead=(y-1)/3*3+1; for(i=1;i&lt;10;++i){ if(i!=x&amp;&amp;s[i][y]==s[x][y]) return false; if(i!=y&amp;&amp;s[x][i]==s[x][y]) return false; } for(i=xhead;i&lt;xhead+3;++i) for(j=yhead;j&lt;yhead+3;++j) if((i!=x||j!=y)&amp;&amp;s[i][j]==s[x][y]) return false; return true; } void dfs(int k){ int i; int j; if(k==n+1){ ++cnt; putchar('\\n'); for(i=1;i&lt;10;++i){ for(j=1;j&lt;10;++j) putchar(s[i][j]+'0'); putchar('\\n'); } return; } i=x[k]; j=y[k]; for(s[i][j]=1;s[i][j]&lt;10;++s[i][j]) if(check(i,j)) dfs(k+1); s[i][j]=0; } int main(){ int i; int j; for(i=1;i&lt;10;++i){ for(j=1;j&lt;10;++j){ s[i][j]=getchar()-'0'; if(!s[i][j]){ ++n; x[n]=i; y[n]=j; } } getchar(); } dfs(1); if(!cnt) puts(&quot;Error&quot;); if(cnt&gt;1) printf(&quot;Total: %d\\n&quot;,cnt); return 0; } 如果需要引入源代码，请注明出处！ ","link":"https://OI-Master.github.io/post/yong-c-yu-yan-shi-xian-shu-du/"},{"title":"Codeforces 命令行工具","content":"经常有人抱怨，说 Codeforces 加载得太慢了，比赛的时候常常爆掉。那么，如何解决这一问题呢？ 其实，有一个很好的助理：Codeforces 命令行工具 。 特点 支持 Codeforces 中的所有编程语言 支持 contests 和 gym 提交代码 动态刷新提交后的情况 拉取问题的样例 本地编译和测试样例 拉取某人的所有代码 从指定模板生成代码（包括时间戳，作者等信息） 列出某场比赛的所有题目的整体信息 用默认的网页浏览器打开题目页面、榜单、提交页面等 丰富多彩的命令行 使用方法 我们现在简易地拟一场比赛的流程。 动图版 文字版 cf race 1136 要开始打 1136 这场比赛了！其中 1136 可以从比赛的链接获取，比方说这个例子的比赛链接就为 https://codeforces.com/contest/1136 。 如果比赛还未开始，则该命令会进行倒计时。比赛已开始或倒计时完后，工具会自动用默认浏览器打开比赛的题目界面与所有题目页面，并拉取样例到本地。 cd 1136/a 进入 A 题的目录，此时该目录下会包含该题的样例。 cf gen 用默认模板生成一份代码，代码文件名默认是题目的 ID。 vim a.cpp 用 Vim 写代码（这取决于你）。 cf test 编译并测试样例。 cf submit 提交代码。 cf list 查看当前比赛各个题目的信息。 cf stand 用浏览器打开榜单，查看排名。 详细版 有可能命令会更新，所以上面的命令会无法使用。这里挂一个最新的命令大全。 首先你得用 &quot;cf config&quot; 命令来配置一下用户名、密码和代码模板。 如果你想用本工具打比赛，那么最好用 &quot;cf race&quot; 命令。 支持的命令: cf config cf submit [-f &lt;file&gt;] [&lt;specifier&gt;...] cf list [&lt;specifier&gt;...] cf parse [&lt;specifier&gt;...] cf gen [&lt;alias&gt;] cf test [&lt;file&gt;] cf watch [all] [&lt;specifier&gt;...] cf open [&lt;specifier&gt;...] cf stand [&lt;specifier&gt;...] cf sid [&lt;specifier&gt;...] cf race [&lt;specifier&gt;...] cf pull [ac] [&lt;specifier&gt;...] cf clone [ac] [&lt;handle&gt;] cf upgrade 参数: -h --help 帮助。 --version 显示版本。 -f &lt;file&gt;, --file &lt;file&gt;, &lt;file&gt; 文件的路径，例如 &quot;a.cpp&quot;、&quot;./temp/a.cpp&quot; &lt;specifier&gt; 任何有用的文本，例如 &quot;https://codeforces.com/contest/100&quot;、 &quot;https://codeforces.com/contest/180/problem/A&quot;、 &quot;https://codeforces.com/group/Cw4JRyRGXR/contest/269760&quot;、 &quot;1111A&quot;、&quot;1111&quot;、&quot;a&quot;、&quot;Cw4JRyRGXR&quot;。 你可以任意组合多个 &lt;specifier&gt; 来说明你的需求。 &lt;alias&gt; 模板的名字，比如 &quot;cpp&quot;。 ac 是否只获取 Accpeted 的代码。 例子: cf config 配置 cf-tool。 cf submit cf 会自动检测你需要提交的文件。 cf submit -f a.cpp cf submit https://codeforces.com/contest/100/A cf submit -f a.cpp 100A cf submit -f a.cpp 100 a cf submit contest 100 a cf submit gym 100001 a cf list 列出当前比赛的题目通过、时限等信息。 cf list 1119 cf parse 100 获取 contest 100 的所有题目的样例到文件夹 &quot;{cf}/{contest}/100/&quot; 中。 cf parse gym 100001a 获取 gym 100001 的 a 题的样例到文件夹 &quot;{cf}/{gym}/100001/a&quot; 中。 cf parse gym 100001 获取 gym 100001 的所有题目的样例到文件夹 &quot;{cf}/{gym}/100001&quot; 中。 cf parse 获取当前比赛的当前题目到当前文件夹下。 cf gen 用默认的模板生成一份代码到当前文件夹下。 cf gen cpp 用名字为 &quot;cpp&quot; 的模板来生成一份代码到当前文件夹下。 cf test 在当前目录下执行模板里的命令，并测试全部样例。如果你想加一组新的测试数据， 新建两个文件 &quot;inK.txt&quot; 和 &quot;ansK.txt&quot; 即可，其中 K 是包含 0~9 的字符串。 cf watch 查看自己在当前比赛的最后 10 次提交结果。 cf watch all 查看自己在当前比赛的全部提交结果 cf open 1136a 用默认的浏览器打开比赛 contest 1136, problem a. cf open gym 100136 用默认的浏览器打开比赛 gym 100136. cf stand 用默认的浏览器打开当前比赛的榜单。 cf sid 52531875 用默认的浏览器打开 52531875 这个提交页面。 cf sid 打开最后一次提交的页面。 cf race 1136 如果比赛还未开始且进入倒计时，则该命令会倒计时。倒计时完后，会自动打开一些 题目页面并拉取样例。 cf pull 100 拉取比赛 id 为 100 每道题的最新代码到文件夹 &quot;./100/&lt;problem-id&gt;&quot; 下。 cf pull 100 a 拉取比赛 id 为 100 的题目 a 的最新代码到文件夹 &quot;./100/a&quot; 下。 cf pull ac 100 a 拉取比赛 id 为 100 的题目 a 的 AC 代码。 cf pull 拉取当前题目的最新代码到当前文件夹下。 cf clone xalanq 拉取 xalanq 的所有提交代码。 cf upgrade 从 GitHub 更新 &quot;cf&quot; 到最新版。 储存的文件: cf 会保存数据到以下文件： &quot;~/.cf/config&quot; 这是配置文件，包括模版等信息。 &quot;~/.cf/session&quot; 这是会话文件，包括 cookies、用户名、密码等。 &quot;~&quot; 这个符号是系统当前用户的主文件夹。 模板: 你可以在你的代码里插入一些标识符，当用 cf 生成代码的时候，标识符会按照以下规则替换： $%U%$ 用户名 (例如 xalanq) $%Y%$ 年 (例如 2019) $%M%$ 月 (例如 04) $%D%$ 日 (例如 09) $%h%$ 时 (例如 08) $%m%$ 分 (例如 05) $%s%$ 秒 (例如 00) 模板内的脚本: 模板支持三个脚本命令，当使用 &quot;cf test&quot; 时会依次执行： - before_script (只会执行一次) - script (有多少个样例就会执行多少次) - after_script (只会执行一次) &quot;before_script&quot; 或者 &quot;after_script&quot; 你可以根据需要来设置，也可以设置为空。 在 &quot;script&quot; 里你必须要运行你的程序，通过标准 IO 来输入/输出数据（不用重定向）。 你在这些脚本命令里也能插入一些标识符，这些标识符会按照以下规则替换： $%path%$ 代码的路径 (不包括 $%full%$， 比如 &quot;/home/xalanq/&quot;) $%full%$ 代码的文件名 (比如 &quot;a.cpp&quot;) $%file%$ 代码的文件名 (不包括后缀，比如 &quot;a&quot;) $%rand%$ 一个长度为 8 的随机字符串 (只包括 &quot;a-z&quot; &quot;0-9&quot; 范围内的字符) 配置模板 当模板被 cf gen 生成时，所有模板内部的占位符会替换成相应的内容，就像 C 语言里的 printf 一样。 规则如下： $%U%$ 用户名 $%Y%$ 年 (e.g. 2019) $%M%$ 月 (e.g. 04) $%D%$ 日 (e.g. 09) $%h%$ 时 (e.g. 08) $%m%$ 分 (e.g. 05) $%s%$ 秒 (e.g. 00) 例如，这就是一个参考模板： /* Generated by powerful Codeforces Tool * You can download the binary file in here https://github.com/xalanq/cf-tool * Author: $%U%$ * Time: $%Y%$-$%M%$-$%D%$ $%h%$:$%m%$:$%s%$ **/ #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(0); return 0; } 安装 说了这么多了，激动人心的时刻到了！ 你可以从这里直接下载一个可执行文件，直接用就好啦。如果你下载不下来，你可以试试 这里 ，密码：123456。不过不保证是最新版！ 你干脆可以把整个 repo 给 clone 下来，然后自己编译 go &gt;= 1.12： git clone https://github.com/xalanq/cf-tool cd cf-tool go build -ldflags &quot;-s -w&quot; cf.go FAQ 我双击了这个程序但是没啥效果 Codeforces Tool 是命令行界面的工具，你应该在终端里运行这个工具。 我无法使用 cf 这个命令 你应该将 cf 这个程序放到一个已经加入到系统变量 PATH 的路径里 (比如说 Linux 里的 /usr/bin/ )。 或者你直接去搜 &quot;怎样添加路径到系统变量 PATH&quot;。 如何加一个新的测试数据 新建两个额外的测试数据文件 inK.txt 和 ansK.txt （K 是包含 0~9 的字符串）。 在终端里启用 tab 补全命令 使用这个工具 Infinidat/infi.docopt_completion 即可。 注意：如果有一个新版本发布（尤其是添加了新命令），你应该重新运行 docopt-completion cf 。 ","link":"https://OI-Master.github.io/post/codeforces-ming-ling-xing-gong-ju/"}]}