<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://OI-Master.github.io</id>
    <title>TianyuZhou</title>
    <updated>2020-04-15T00:36:59.728Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://OI-Master.github.io"/>
    <link rel="self" href="https://OI-Master.github.io/atom.xml"/>
    <subtitle>TianyuZhou 小蒟蒻的博客</subtitle>
    <logo>https://OI-Master.github.io/images/avatar.png</logo>
    <icon>https://OI-Master.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, TianyuZhou</rights>
    <entry>
        <title type="html"><![CDATA[Codeforces Contest 1324 C 题解]]></title>
        <id>https://OI-Master.github.io/post/codeforces-contest-1324-c-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/codeforces-contest-1324-c-ti-jie/">
        </link>
        <updated>2020-04-14T00:28:06.000Z</updated>
        <summary type="html"><![CDATA[<p>这一道题可以说把我的思维弄得乱七八糟，想出来正解后感觉自己实在是太蠢了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一道题可以说把我的思维弄得乱七八糟，想出来正解后感觉自己实在是太蠢了。</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>上链接：<a href="https://codeforces.com/contest/1324/problem/C">https://codeforces.com/contest/1324/problem/C</a></p>
<h3 id="中文题面">中文题面</h3>
<p>现在河面上有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 块石头，编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">1~n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mord mathdefault">n</span></span></span></span>块石头每块上有一个方向，如果是 <code>L</code>，那么青蛙到这块石头上之后只能往左跳，如果是 <code>R</code> 只能往右，当然，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 块石头的方向是 <code>R</code>。<br>
现在青蛙要从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 跳到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，请问他应该怎么跳才能让他跳跃过程中跳跃距离最长的最小呢？输出这个距离。</p>
<h2 id="思路">思路</h2>
<p>这道题是贪心的题目。我们发现，往左边跳其实并不划算，我们往左边跳的时候，距离就会更远，我们想跳的只是朝向右边的石头。这时候，这道题就很简单了，直接求出所有向右边的石头的坐标差，取其中最大值即可。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-15 00:06:42
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t;
	cin&gt;&gt;t;
	while(t--){
		string s;
		cin&gt;&gt;s;
		vector&lt;int&gt;v;
		v.push_back(0);
		for(int i=0;i&lt;s.size();++i)
			if(s[i]=='R')
				v.push_back(i+1);
		v.push_back(s.size()+1);
		int maxv=-1;
		for(int i=1;i&lt;v.size();++i)
			maxv=max(maxv,v[i]-v[i-1]);
		cout&lt;&lt;maxv&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Contest 1335 D 题解]]></title>
        <id>https://OI-Master.github.io/post/codeforces-contest-1335-d-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/codeforces-contest-1335-d-ti-jie/">
        </link>
        <updated>2020-04-13T00:58:10.000Z</updated>
        <summary type="html"><![CDATA[<p>这可以说是我在这场比赛中看到的最简单的题目。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这可以说是我在这场比赛中看到的最简单的题目。</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>请到 <a href="https://codeforces.com/problemset/problem/1335/D">https://codeforces.com/problemset/problem/1335/D</a> 去查看。<s>另外，我告诉你们一个特大消息，我昨天奇迹地上去了主站！</s></p>
<h3 id="中文题面">中文题面</h3>
<p>就是给你一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo>×</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">9\times 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 的普通数独，九宫格数独，已经填好的，保证合法。如果你不知道数独的规则，可以到 <a href="https://oi-master.github.io/post/yong-c-yu-yan-shi-xian-shu-du/#%E8%A7%84%E5%88%99">这里</a> 查看，也是我写的。<br>
<img src="https://OI-Master.github.io/post-images/1586826661046.png" alt="数独" loading="lazy"><br>
然后我们需要改变最多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 个数，是这个数独变成一个 Anti-Sudoku ，它的意思是，每行每列每宫中至少有两个数相等。<br>
输入一个数独，输出你改的 Anti-Sudoku ，如果有多种解， You can print any。<br>
你需要回答 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 组数据。</p>
<h2 id="思路">思路</h2>
<p>根据我的小研究，我们只需要把所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 改成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 即可。<br>
为什么这样子就可以？因为，这个原来的数独就是一个满足九宫格数独的要求，就是说每行、每列、每宫都没有重复，那么改一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，可以保证行至少有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> （原来的一个加上现在新改的一个），每列也会发生重复（原来的一个再加上现在新改的一个），每宫也是一样，所以能保证符合题目 Anti-Sudoku 的要求。</p>
<p>我觉得这种方法最简单，不过 dalao 们改一些特定坐标的方法我也是同意的，不过觉得我这种做法更方便，毕竟思维难度、代码难度都低了嘛。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-13 15:08:09
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t;
	cin&gt;&gt;t;
	while(t--){
		for(int i=0;i&lt;9;++i){
			for(int j=0;j&lt;9;++j){
				char c;
				cin&gt;&gt;c;
				if(c=='1')
					cout&lt;&lt;2;
				else
					cout&lt;&lt;c;
			}
			cout&lt;&lt;endl;
		}
	}
	return 0;
}
</code></pre>
<p>为什么感觉题目与思路的比例不对？？？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces 上创建 Mashup 比赛]]></title>
        <id>https://OI-Master.github.io/post/codeforces-shang-chuang-jian-mashup-bi-sai/</id>
        <link href="https://OI-Master.github.io/post/codeforces-shang-chuang-jian-mashup-bi-sai/">
        </link>
        <updated>2020-04-11T05:12:19.000Z</updated>
        <summary type="html"><![CDATA[<p>公开比赛必须要蓝名才能创建哦！Mashup 是私人比赛。</p>
]]></summary>
        <content type="html"><![CDATA[<p>公开比赛必须要蓝名才能创建哦！Mashup 是私人比赛。</p>
<!-- more -->
<h2 id="步骤">步骤</h2>
<p>那，我们就开始了。</p>
<ol>
<li>首先，进入 <a href="https://codeforces.com">Codeforces主站</a> 。由于我上不去所以就用 <a href="https://codeforc.es">https://codeforc.es</a>，步骤一样。<br>
<img src="https://OI-Master.github.io/post-images/1586668670688.png" alt="1" loading="lazy"></li>
<li>接下来，点击GYM。<br>
<img src="https://OI-Master.github.io/post-images/1586668700548.jpg" alt="2" loading="lazy"></li>
<li>然后点击MASHUPS。<br>
<img src="https://OI-Master.github.io/post-images/1586668722184.png" alt="3" loading="lazy"></li>
<li>然后 Create new mashup。<br>
<img src="https://OI-Master.github.io/post-images/1586668743558.png" alt="4" loading="lazy"></li>
<li>输入标题等信息。如果需要将一场比赛完全复制进入 Mashup，可以点击 Clone Contest 。不过如果不要的话就别选（反正我一般不点）。<br>
<img src="https://OI-Master.github.io/post-images/1586668765662.png" alt="5" loading="lazy"></li>
<li>然后可以看到这样子的画面：<br>
<img src="https://OI-Master.github.io/post-images/1586668788666.png" alt="6" loading="lazy"></li>
<li>发公告，回答问题。<br>
<img src="https://OI-Master.github.io/post-images/1586668809866.png" alt="7" loading="lazy"></li>
<li>添加题目，在 PROBLEMSET 里找题目。<br>
<img src="https://OI-Master.github.io/post-images/1586668833146.png" alt="8" loading="lazy"></li>
<li>进入 admin 页面。<br>
<img src="https://OI-Master.github.io/post-images/1586668867850.png" alt="9" loading="lazy"></li>
<li>编辑比赛（由于选项太多我就解释几个，不解释全部了）。<br>
<img src="https://OI-Master.github.io/post-images/1586668937723.png" alt="10A" loading="lazy"><br>
<img src="https://OI-Master.github.io/post-images/1586668957882.png" alt="10B" loading="lazy"><br>
<img src="https://OI-Master.github.io/post-images/1586668966959.png" alt="10C" loading="lazy"></li>
<li>邀请大家，输入用户名或者生成链接。<br>
<img src="https://OI-Master.github.io/post-images/1586668990702.png" alt="11A" loading="lazy"><br>
<img src="https://OI-Master.github.io/post-images/1586669009494.png" alt="11B" loading="lazy"></li>
<li>其他。<br>
<img src="https://OI-Master.github.io/post-images/1586669036269.png" alt="12" loading="lazy"></li>
<li>比赛时当您开启管理模式时，可以查看所有人代码，没有开启的话，CF会将您看待为普通参赛者。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Contest 1099 C 题解]]></title>
        <id>https://OI-Master.github.io/post/codeforces-contest-1099-c-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/codeforces-contest-1099-c-ti-jie/">
        </link>
        <updated>2020-04-09T12:29:10.000Z</updated>
        <summary type="html"><![CDATA[<p>我又来写题解了！</p>
]]></summary>
        <content type="html"><![CDATA[<p>我又来写题解了！</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>链接在 <a href="https://codeforces.com/contest/1099/problem/C">这里</a> ，自己进去看。</p>
<h3 id="中文题面">中文题面</h3>
<p>翻译如下：</p>
<blockquote>
<p><strong>Description</strong><br>
给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的字符串，尽可能包含小写字母，字符 <code>?</code> 和字符 <code>*</code>。保证上面两种特殊字符若出现则一定出现在一个小写字母的后面一位。要求构造一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的新字符串，它和原串有如下关系：</p>
<ul>
<li>按照原串的字母顺序向新串中填充，新串中含且仅含小写字母。</li>
<li>若原串的某小写字母后没有特殊字符，则这个字母在新串中必须保留。</li>
<li>若原串的某小写字母后有字符 <code>?</code>，则这个字母在新串中可以被保留，也可以被删除。</li>
</ul>
<p>若原串某小写字母后有字符 <code>*</code>，则这个字母在新串中可以被保留，可以被删除，也可以被复读很多遍。<br>
<strong>Input</strong><br>
第一行是一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的字符串，保证输入合法；<br>
第二行是一个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 代表要求构造的新串长度。<br>
<strong>Output</strong><br>
输出一行一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的字符串，为构造出的串。<br>
若不存在这样的串，输出 <code>Impossible</code>。<br>
<strong>Hint</strong><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mn>200</mn></mrow><annotation encoding="application/x-tex">1\leq n,k\leq 200</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span></span></span><br>
translated by <strong>一扶苏一</strong></p>
</blockquote>
<h2 id="思路">思路</h2>
<p>这是一道经典的模拟。<br>
由于宏观简单，我们就看微观了。</p>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-11 03:33:32
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
</code></pre>
<p>毫无质量的东西，这些是板子。</p>
<pre><code class="language-cpp">string s;
int k;
cin&gt;&gt;s&gt;&gt;k;
</code></pre>
<p>毫无质量的东西，这些是输入。</p>
<pre><code class="language-cpp">int sum=0;                   
for(int i=0;i&lt;s.size();++i)  
	if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') 
		++sum;               
	else if(s[i]=='*'){      
		sum=10000000000000;  
		break;               
	}                        
if(sum&lt;k){                   
	cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;
		return 0;
}
</code></pre>
<p><s>毫无质量的东西，这些是循环。</s><br>
才怪呢，我们发现，只要是字母都把它加上去，如果是 <code>*</code> 就说明能重复无数次。<br>
原来是看最大能到多少。</p>
<pre><code class="language-cpp">sum=0;                   
for(int i=0;i&lt;s.size();++i)
	if(s[i]=='?'||s[i]=='*')
		--sum;
	else
		++sum;
if(sum&gt;k){
	cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;
	return 0;
}
</code></pre>
<p><s>毫无质量的东西，这些也是循环。</s><br>
我们再来看看这是什么用的。<br>
我们发现，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是字母的话，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，如果是字符，就让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 扣掉 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。<br>
发现，我们算的东西就是最少长度是多少，只要一个字母后面有 <code>*</code> 或者是 <code>?</code> 的话，就不算这个字母（删掉）。<br>
最后比较一下。</p>
<pre><code class="language-cpp">vector&lt;char&gt;ans;
for(int i=1;i&lt;s.size();++i)
	if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'&amp;&amp;s[i-1]&gt;='a'&amp;&amp;s[i-1]&lt;='z')
		ans.push_back(s[i-1]);
	else if(s[i]=='?'&amp;&amp;sum&lt;k){
		++sum;
		ans.push_back(s[i-1]);
	}
	else if(s[i]=='*'&amp;&amp;sum&lt;k)
		while(sum&lt;k){
			++sum;
			ans.push_back(s[i-1]);
		}
</code></pre>
<p>核心部分啦！<br>
如果这个字符是字母，不是符号，前面一个也不是符号，那么就说明前面一个必须要选，进 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 里面。<br>
否则，如果是问号的话，并且串长不够，那么就把字母压到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 里。<br>
如果是 <code>*</code> 的话，那么可以把串长补到够，一直加，没有副作用。<br>
这一段我故意写得稍微有些简洁，想让大家再看几下代码，好好理解。</p>
<pre><code class="language-cpp">    if(s[s.size()-1]&gt;='a'&amp;&amp;s[s.size()-1]&lt;='z')
		ans.push_back(s[s.size()-1]);
	for(int i=0;i&lt;ans.size();++i)
		cout&lt;&lt;ans[i];
    return 0;
}
</code></pre>
<p>这一段好像的确没什么难的了，就是打印。</p>
<h2 id="代码">代码</h2>
<p>完整代码如下：</p>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-11 03:33:32
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	string s;
	int k;
	cin&gt;&gt;s&gt;&gt;k;
	int sum=0;
	for(int i=0;i&lt;s.size();++i)
		if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')
			++sum;
		else if(s[i]=='*'){
			sum=10000000000000;
			break;
		}
	if(sum&lt;k){
		cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;
		return 0;
	}
	sum=0;
	for(int i=0;i&lt;s.size();++i)
		if(s[i]=='?'||s[i]=='*')
			--sum;
		else
			++sum;
	if(sum&gt;k){
		cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl;
		return 0;
	}
	vector&lt;char&gt;ans;
	for(int i=1;i&lt;s.size();++i)
		if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'&amp;&amp;s[i-1]&gt;='a'&amp;&amp;s[i-1]&lt;='z')
			ans.push_back(s[i-1]);
		else if(s[i]=='?'&amp;&amp;sum&lt;k){
			++sum;
			ans.push_back(s[i-1]);
		}
		else if(s[i]=='*'&amp;&amp;sum&lt;k)
			while(sum&lt;k){
				++sum;
				ans.push_back(s[i-1]);
			}
	if(s[s.size()-1]&gt;='a'&amp;&amp;s[s.size()-1]&lt;='z')
		ans.push_back(s[s.size()-1]);
	for(int i=0;i&lt;ans.size();++i)
		cout&lt;&lt;ans[i];
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Contest 1134 C 题解]]></title>
        <id>https://OI-Master.github.io/post/codeforces-contest-1134-c-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/codeforces-contest-1134-c-ti-jie/">
        </link>
        <updated>2020-04-09T07:05:06.000Z</updated>
        <summary type="html"><![CDATA[<p>这一道题我昨天晚上做了很久，不过最后居然 AC 了。貌似大家都没有 AC 呀，我写一篇题解吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一道题我昨天晚上做了很久，不过最后居然 AC 了。貌似大家都没有 AC 呀，我写一篇题解吧。</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>为什么要给呢，直接去 <a href="https://codeforces.com/contest/1334/problem/C">这里</a> 就好了啊。</p>
<h3 id="中文题面">中文题面</h3>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 头凶猛的怪兽，他们围成一个圈圈，顺时针编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1, 2, 3, 4, \dots , N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 每一头怪兽都有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 个属性——一个是它的生命值，第二个是它的爆炸值。爆炸会发生在它生命值小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，就是说他死掉的时候，它的下一头怪兽会遭到 它的爆炸值 点伤害。如果下一头怪兽已经死了，则无伤害。如果这回又把下一头怪兽给弄死了，那么下一头怪兽也会爆炸，连环炸到下下头怪兽……你还有一把枪，每发子弹可以伤害一头怪兽的生命值 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 点。问你，把怪兽都炸掉，要用多少子弹。</p>
<h2 id="思路">思路</h2>
<p>我们知道，打掉怪兽有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 种可能。第一种，就是专门拿枪一发一发地打它，一种是先打 这个怪兽的生命值-上个怪兽的爆炸值 发，也就是说，最后让上一个怪兽把它爆掉。我们发现，不管怎么打， “这个怪兽的生命值-上个怪兽的爆炸值 发”肯定是要的，于是我们先打这么多发。<br>
这时候，又出现了一个情况。我们发现，在怪兽中间，出现了一个“环”，只要有一个怪兽死了，大家都会被连环炸掉。所以，我们只需要打死现在生命值最小的怪兽即可。</p>
<h2 id="代码">代码</h2>
<p>别抄袭啊！</p>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-10 15:45:27
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
struct node{
	int h;
	int b;
	int c;
};
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n;
		cin&gt;&gt;n;
		node a[n];
		for(int i=0;i&lt;n;++i)
			cin&gt;&gt;a[i].h&gt;&gt;a[i].b;
		if(n==1){
			cout&lt;&lt;a[0].h&lt;&lt;endl;
			continue;
		}
		a[0].c=a[0].h-a[n-1].b;
		for(int i=1;i&lt;n;++i)
			a[i].c=a[i].h-a[i-1].b;
		int sum=0;
		for(int i=0;i&lt;n;++i)
			if(a[i].c&gt;0){
				sum+=a[i].c;
				a[i].h-=a[i].c;
			}
		int minv=1000000000000;
		for(int i=0;i&lt;n;++i)
			minv=min(minv,a[i].h);
		cout&lt;&lt;sum+minv&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法脑图]]></title>
        <id>https://OI-Master.github.io/post/suan-fa-nao-tu/</id>
        <link href="https://OI-Master.github.io/post/suan-fa-nao-tu/">
        </link>
        <updated>2020-04-06T18:12:28.000Z</updated>
        <summary type="html"><![CDATA[<p>图片来源于网络，侵权删。</p>
]]></summary>
        <content type="html"><![CDATA[<p>图片来源于网络，侵权删。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://OI-Master.github.io/post-images/1586225603861.png" alt="脑图" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Contest 1102 B 题解]]></title>
        <id>https://OI-Master.github.io/post/codeforces-contest-1102-b-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/codeforces-contest-1102-b-ti-jie/">
        </link>
        <updated>2020-04-06T13:38:05.000Z</updated>
        <summary type="html"><![CDATA[<p>我又来写题解了，呵呵呵，最近沉迷于刷题、写题解，无法自拔……<br>
好了，不说别的了，现在快点进入正题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我又来写题解了，呵呵呵，最近沉迷于刷题、写题解，无法自拔……<br>
好了，不说别的了，现在快点进入正题。</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>这里从来不会出现英文题面的好吗，需要你去 <a href="http://codeforces.com/problemset/problem/1102/B">这里</a> 看的。</p>
<h3 id="中文题面">中文题面</h3>
<p>写完今早的题解后，我想了想，决定还是把题目的意思放出来，能节约大家的时间。<br>
给出一个长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 种颜色,用这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 种颜色给 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 中的元素染色，要求：</p>
<ul>
<li>每个元素都要被染色</li>
<li>每种颜色都要被使用</li>
<li>每种颜色不会被用于相同的元素（即若颜色 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mi>c</mi><mi>j</mi></msub><mo>(</mo><mi>i</mi><mi mathvariant="normal">≠</mi><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">c_i = c_j(i \neq j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> ，必须保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">≠</mi><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i \neq a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>）</li>
</ul>
<p>如果没有可行的方案，输出 <code>NO</code> ,否则输出 <code>YES</code> 和任何一种可行的方案。</p>
<h2 id="思路">思路</h2>
<p>首先先膜拜一下大佬 xyf007 ，他写的这篇洛谷题解引发了我的思路（虚拟赛后看见的，大家别以为我作弊），然后我想了想，决定写一下这篇题解。<br>
我们这道题的确完全不用各种各样的高级算法，什么桶排序、什么双指针、什么vis数组，都不要，我们只要结构体，一个变量 <code>num</code> ，就可以做了。<br>
如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的话，肯定用不完所有的数字，输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。<br>
我们首先判断是否有数字出现次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">&gt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> ，如果有，那么一定不行的。<br>
如果没有，那么一定行。我们像这样填色。</p>
<ul>
<li>先将数组按照大小排序</li>
<li>然后让一个变量 <code>num</code> 来从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 循环，到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就把它赋值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
<li>轮流填， <code>num</code> 是多少就填多少。</li>
</ul>
<p>想想，为什么这样子可以？<br>
然后就十分简单，我们按照原始数列的编号排个序，输出即可。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-07 11:06:01
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
struct node{
	int id,val,b;
};
bool cmp1(node x,node y){
	return x.val&lt;y.val;
}
bool cmp2(node x,node y){
	return x.id&lt;y.id;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n,k;
	cin&gt;&gt;n&gt;&gt;k;
	if(n&lt;k){
		cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
		return 0;
	}
	node a[n];
	int b[5001];
	for(int i=1;i&lt;=5000;++i)
		b[i]=0;
	for(int i=0;i&lt;n;++i){
		a[i].id=i;
		cin&gt;&gt;a[i].val;
		++b[a[i].val];
		if(b[a[i].val]&gt;k){
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
			return 0;
		}
	}
	sort(a,a+n,cmp1);
	int num=1;
	for(int i=0;i&lt;n;++i){
		a[i].b=num;
		++num;
		if(num==k+1)
			num=1;
	}
	sort(a,a+n,cmp2);
	cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
	for(int i=0;i&lt;n;++i)
		cout&lt;&lt;a[i].b&lt;&lt;' ';
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Contest 1010 B & 1011 D 题解]]></title>
        <id>https://OI-Master.github.io/post/codeforces-contest-1010-b-and-1011-d-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/codeforces-contest-1010-b-and-1011-d-ti-jie/">
        </link>
        <updated>2020-04-06T07:37:08.000Z</updated>
        <summary type="html"><![CDATA[<p>不出你的意料，今天我又来写题解了（你可能会问我为什么还没有开学）。这一次我写的题解是一道交互题的题解，毕竟是第一次写这种交互题的题解，写得不太好请大家别太在意，您可以在评论区来留言，我会根据你的留言来完善一下本篇题解或是下一篇题解。<br>
好的，我们仍然按照老配方，题面先。</p>
]]></summary>
        <content type="html"><![CDATA[<p>不出你的意料，今天我又来写题解了（你可能会问我为什么还没有开学）。这一次我写的题解是一道交互题的题解，毕竟是第一次写这种交互题的题解，写得不太好请大家别太在意，您可以在评论区来留言，我会根据你的留言来完善一下本篇题解或是下一篇题解。<br>
好的，我们仍然按照老配方，题面先。</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>如果你以前看过我写 Codeforces 的题解，你应该很清楚， <a href="https://codeforces.com/contest/1010/problem/B">这里</a>会挂个链接，而不会写题面。</p>
<h3 id="中文题面">中文题面</h3>
<p>请去 <a href="https://www.luogu.com.cn/problem/CF1010B">洛谷站内</a> 了解。嘿，有点过分，上次是直接复制洛谷的翻译，这次只给个链接？！是的，没错，翻译的很好，“抽风”这个词十分得恰当。</p>
<h2 id="思路">思路</h2>
<p>省掉了题面，这一篇文章短多了。我们首先假设，火箭不会抽风，那么你会怎么做？很显然，我们可以二分一下这个值，每次输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span> ，看一下交互器的相应。<br>
但是，事实上没有这么好，火箭随时可能抽风，那么假设我们知道抽风的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> ，那么是不是这一道题也很简单？我们看见本轮火箭要抽风了，我们就把火箭的答案反转一下，也可以二分。<br>
问题是，现在我们并不知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> ，那么怎么搞？等等，我们先放着。<br>
我们可以先了解一下，二分至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 要多少次。我们用 Python 求一下吧。</p>
<pre><code class="language-python">tmp=1
tot=0
while tmp&lt;1000000000 :
    tot+=1
    tmp*=2
print(tot)
</code></pre>
<p>输出了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>，这时候我们貌似想到了什么……<br>
我们惊讶地发现，火箭抽风的周期也是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> ，加起来就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>60</mn></mrow><annotation encoding="application/x-tex">60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span> 次！<br>
那么很显然，我们可以拿前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 次来确定火箭抽风的序列，然后把后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 次用来二分。这个想法实在是太好了！<br>
还有，我们前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn></mrow><annotation encoding="application/x-tex">30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> 次怎么确定？其实我们只需要一直输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 就可以了，如果它输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，那么本轮就不会抽风，如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> ，那么就说明会抽风，如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，那么数据太巧，要特判。<br>
然后，就是可爱的代码啦。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-07 07:13:12
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	int a[m+1],tmp;
	for(int i=1;i&lt;=m;++i){
		cout&lt;&lt;1&lt;&lt;endl;
		cout.flush();
		cin&gt;&gt;tmp;
		if(tmp==0)
			return 0;
		if(tmp==-2)
			return 0;
		if(tmp==1)
			a[i]=1;
		else
			a[i]=0;
	}
	int left=2;
	int right=n;
	int mid;
	int mod=0;
	while(left&lt;=right){
		++mod;
		if(mod==m+1)
			mod=1;
		mid=(left+right)/2;
		cout&lt;&lt;mid&lt;&lt;endl;
		cout.flush();
		cin&gt;&gt;tmp;
		if(tmp==0)
			return 0;
		if(tmp==-2)
			return 0;
		if(a[mod]==0)
			tmp=-tmp;
		if(tmp==1)
			left=mid+1;
		else
			right=mid-1;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Contest 262 B 题解]]></title>
        <id>https://OI-Master.github.io/post/codeforces-contest-262-b-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/codeforces-contest-262-b-ti-jie/">
        </link>
        <updated>2020-04-06T02:26:38.000Z</updated>
        <summary type="html"><![CDATA[<p>这道题是我下午做的，你在源代码里的 Time 就会发现。是的，没错，不过晚上我还要打一场虚拟。<br>
貌似这道题洛谷没人写题解呀，我就把这个坑填上吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这道题是我下午做的，你在源代码里的 Time 就会发现。是的，没错，不过晚上我还要打一场虚拟。<br>
貌似这道题洛谷没人写题解呀，我就把这个坑填上吧。</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>请去 <a href="https://codeforces.com/contest/262/problem/B">Codeforces</a> 官网上看吧，我这里不做介绍</p>
<h3 id="中文题面">中文题面</h3>
<p>一个人要统计他所在公司的总收入并且他想使总收入达到最大，收入写在一条清单上，总收入是清单上所有数之和。<br>
他有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次操作的机会，每次操作可以将某个数一个数变成其相反数，例如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> （注意，他必须严格执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次）问总收入最大是多少？（作弊啊，同志</p>
<h2 id="思路">思路</h2>
<p>简单水题，瞬间秒杀！<br>
这道题的确很水的好不好，可是弱弱的我就因为一个小错误 WA 了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 次，唉。<br>
这道题由于是到简单题，所以我决定从微观开始讲。<br>
首先是板子</p>
<pre><code class="language-cpp">/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-06 16:45:57
**/
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
</code></pre>
<p>呵呵呵，板子有点长，接下来是简单得不能再简单的输入。</p>
<pre><code class="language-cpp">int n,m;
cin&gt;&gt;n&gt;&gt;m;
int a[n];
for(int i=0;i&lt;n;++i)
	cin&gt;&gt;a[i];
</code></pre>
<p>这种题目，显然要排序。</p>
<pre><code class="language-cpp">sort(a,a+n);
</code></pre>
<p>然后呢，我们就要详细地讲一下这一段。</p>
<pre><code class="language-cpp">int j=0;
while(a[j]&lt;0&amp;&amp;m&gt;0){
	a[j]*=-1;
	--m;
	++j; 
}
if(a[j]==0)
	m=0;
</code></pre>
<p>怎么解释？我们先看 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> ，大家应该都知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 是什么意思吧，就是说现在看到第几个了。你可能会问，为什么不用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，因为我习惯把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 作为 <code>for</code> 循环的变量，如果定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 的话，将会编译错误。当你看到完整代码的时候，你就会知道为什么要用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 而不用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 。<br>
然后我们先不扯 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的问题，就看中间这一段。如果你不会做这道题的话，我觉得对于这一段的问题还是挺大的。<br>
我们大概能通过字面意思了解到，这一段话的作用就是把所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\leq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的数字中前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 小的挑出来（当然如果没有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 这么多就是全挑出来），乘上一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> ，相当于负的变成正的。如果有多的，那么后面在应用于正数上。<br>
那么后面的 <code>if</code> 语句又是怎么回事？其实，我们发现， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 是一个神奇的数字，当我们搞到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的时候，我们可以搞任意多次，把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 耗光，就不用搞到正数上面了，搞到正数上面可能还会起到副作用。<br>
好，那么接下来，我们就要处理一下当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 还没用完的情况了。<br>
还是上代码。</p>
<pre><code class="language-cpp">sort(a,a+n);
if(m&amp;1)
	a[0]*=-1;
</code></pre>
<p>首先，先排序。<br>
然后，我们发现，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 是偶数的时候，我们可以把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 用在一个数字上，会抵消，所以没用。<br>
如果是奇数的话，我们又会发现，操作在最小的数字上最划算，而且操作完后相当于动一下（因为偶数就抵消了），所以就可以直接放心地把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 乘上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>。</p>
<pre><code class="language-cpp">    int sum=0;
    for(int i=0;i&lt;n;++i)
	    sum+=a[i];
    cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><s>这些有什么好看的</s></p>
<h2 id="代码">代码</h2>
<p>我已经把所有的代码都展示出来了，大家自己拼吧（逃</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Atcoder ABC 160 E 题解]]></title>
        <id>https://OI-Master.github.io/post/atcoder-abc-160-e-ti-jie/</id>
        <link href="https://OI-Master.github.io/post/atcoder-abc-160-e-ti-jie/">
        </link>
        <updated>2020-04-05T18:03:42.000Z</updated>
        <summary type="html"><![CDATA[<p>首先，感谢大佬 hhhyyyfff 和他的程序，它们开导了我的思路。好了，现在开始正题了，先讲一下题面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>首先，感谢大佬 hhhyyyfff 和他的程序，它们开导了我的思路。好了，现在开始正题了，先讲一下题面。</p>
<!-- more -->
<h2 id="题面">题面</h2>
<h3 id="英文题面">英文题面</h3>
<p>请你点 <a href="https://atcoder.jp/contests/abc160/tasks/abc160_e">这里</a>，会带你去 AtCoder 的官网。</p>
<h3 id="中文题面">中文题面</h3>
<p>你们将吃 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 个红苹果和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 个青苹果。</p>
<p>你有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 个美味的红苹果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">p_1,p_2,...,p_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 个美味的青苹果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>q</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">q_1,q_2,...,q_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 个无色美味的苹果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>r</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">r_1,r_2,...,r_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br>
在吃无色苹果之前，你可以把它涂成红色或绿色，它将分别算作红色或青色苹果。<br>
从上面的苹果中，你可以选择要吃的苹果，同时把吃过的苹果的美味之和尽可能地做大。</p>
<p>找出将零个或更多无色苹果进行最佳着色时所能达到的吃掉苹果美味的最大可能总和。</p>
<p>输入格式大家自己看吧，我不翻译了。</p>
<h2 id="思路">思路</h2>
<p>这道题比 D 题简单，不过比赛的时候没出来……其实就是一个大根堆，来维护一下所有的苹果的美味程度，同时记录下来这个苹果的颜色。然后，每次把堆顶拿出来。如果堆顶是一个红色苹果，且还没有吃到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 个红苹果，那么就吃！如果堆顶是一个青色苹果，且还没有吃到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 个青苹果，还是马上就吃！如果是一个无色的苹果，先不计数，然后将剩下的总数减掉一。当然，吃有颜色的苹果时，也要将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 或者是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 减掉一，同时把苹果的总数也减掉一。我语文很差，但是代码写得还行，所以大家先看代码吧。不理解的可以在评论留言。</p>
<h2 id="代码">代码</h2>
<p>那么，就上代码啦。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
using namespace std;
#define int long long
signed main(){
	int x,y,a,b,c;
	cin&gt;&gt;x&gt;&gt;y&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	priority_queue&lt;pair&lt;int,int&gt; &gt;h;
	while(a--){
		int w;
		cin&gt;&gt;w;
		h.push(make_pair(w,1));
	}
	while(b--){
		int w;
		cin&gt;&gt;w;
		h.push(make_pair(w,2));
	}
	while(c--){
		int w;
		cin&gt;&gt;w;
		h.push(make_pair(w,3));
	}
	int z=x+y;
	int ans=0;
	while(z){
		pair&lt;int,int&gt;f=h.top();
		h.pop();
		if(f.second==3){
			ans+=f.first;
			--z;
		}
		else if(f.second==1&amp;&amp;x){
			ans+=f.first;
			--x;
			--z;
		}
		else if(f.second==2&amp;&amp;y){
			ans+=f.first;
			--y;
			--z;
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>本文到此结束，谢谢您的观看。</p>
]]></content>
    </entry>
</feed>